<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Sources</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400,700" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <script>
      function detectDarkTheme(toggle) {
        var prefersDarkSchemeSetting = localStorage.getItem("prefersDarkScheme")
        if (prefersDarkSchemeSetting == null) {
          prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        } else {
          prefersDarkScheme = prefersDarkSchemeSetting == "true"
        }

        if (toggle) {
          if (prefersDarkScheme) {
            prefersDarkScheme = false
            localStorage.setItem("prefersDarkScheme", "false")
          } else {
            prefersDarkScheme = true
            localStorage.setItem("prefersDarkScheme", "true")
          }
        }

        if (prefersDarkScheme) {
          document.body.classList.add('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby-dark.png"
          })
        } else {
          document.body.classList.remove('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby.png"
          })
        }
      }

      detectDarkTheme(false)
    </script>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img class="graphql-ruby-img" src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <div class="nav-links">
            <a href="/getting_started">Get Started</a>
            <a href="/guides">Guides</a>
            <a href="/api-doc/2.5.7/">API</a>
            <a href="https://buttondown.email/graphql-ruby">Newsletter</a>
            <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
            <a href="https://graphql.pro">Upgrade to Pro</a>
            <input
              class="search-input"
              onkeyup="GraphQLRubySearch.run(this)"
              type="text"
              placeholder="Search the docs..."
            />
            <a href="#" onclick="event.preventDefault(); detectDarkTheme(true)" class="dark-theme-button"></a>
          </div>
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container  fullwidth ">
      <ul class="breadcrumb">
  <li><a href="/guides">Guides</a></li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/schema/definition.html">Schema</option>
      
        <option  data-target="/queries/executing_queries.html">Queries</option>
      
        <option  data-target="/type_definitions/objects.html">Type Definitions</option>
      
        <option  data-target="/authorization/overview.html">Authorization</option>
      
        <option  data-target="/fields/introduction.html">Fields</option>
      
        <option  data-target="/mutations/mutation_root.html">Mutations</option>
      
        <option  data-target="/errors/overview.html">Errors</option>
      
        <option  data-target="/pagination/overview.html">Pagination</option>
      
        <option  data-target="/relay/range_add.html">Relay</option>
      
        <option  selected data-target="/dataloader/overview.html">Dataloader</option>
      
        <option  data-target="/subscriptions/overview.html">Subscriptions</option>
      
        <option  data-target="/pro/home.html">GraphQL Pro</option>
      
        <option  data-target="/operation_store/overview.html">GraphQL Pro - OperationStore</option>
      
        <option  data-target="/defer/overview.html">GraphQL Pro - Defer</option>
      
        <option  data-target="/limiters/overview.html">GraphQL Enterprise - Rate Limiters</option>
      
        <option  data-target="/object_cache/overview.html">GraphQL Enterprise - Object Cache</option>
      
        <option  data-target="/changesets/overview.html">GraphQL Enterprise - Changesets</option>
      
        <option  data-target="/javascript_client/overview.html">JavaScript Client</option>
      
        <option  data-target="/language_tools/visitor.html">Language Tools</option>
      
        <option  data-target="/testing/overview.html">Testing</option>
      
        <option  data-target="/development.html">Other</option>
      
    </select>
  </li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/dataloader/overview.html">Overview</option>
      
        <option  selected data-target="/dataloader/sources.html">Sources</option>
      
        <option  data-target="/dataloader/dataloader.html">Dataloader</option>
      
        <option  data-target="/dataloader/adopting.html">Dataloader vs. GraphQL-Batch</option>
      
        <option  data-target="/dataloader/testing.html">Testing</option>
      
        <option  data-target="/dataloader/async_dataloader.html">Async Source Execution</option>
      
        <option  data-target="/dataloader/parallelism.html">Manual Parallelism</option>
      
    </select>
  </li>
</ul>



<h1 class="guide-header">Sources</h1>
<div class="guide-table-of-contents"><div class="table-of-contents">
  <h3 class="contents-header">Contents</h3>
  <ol class='contents-list'><li class='contents-entry'><a href='#source-concepts'>Source Concepts
</a></li><li class='contents-entry'><a href='#example-loading-strings-from-redis-by-key'>Example: Loading Strings from Redis by Key
</a></li><li class='contents-entry'><a href='#example-loading-activerecord-objects-by-id'>Example: Loading ActiveRecord Objects by ID
</a></li><li class='contents-entry'><a href='#example-batched-calculations'>Example: Batched Calculations
</a></li><li class='contents-entry'><a href='#example-loading-in-a-background-thread'>Example: Loading in a background thread
</a></li><li class='contents-entry'><a href='#filling-the-dataloader-cache'>Filling the Dataloader Cache
</a></li><li class='contents-entry'><a href='#de-duplicating-equivalent-objects'>De-duplicating equivalent objects
</a></li></ol>
</div>
</div>
<div class="guide-container">
  <p><em>Sources</em> are what <a href="/api-doc/2.5.7/GraphQL/Dataloader" target="_blank" title="API docs for GraphQL::Dataloader"><code>GraphQL::Dataloader</code></a> uses to fetch data from external services.</p>

<h2 id="source-concepts">Source Concepts</h2>

<p>Sources are classes that inherit from <code class="language-plaintext highlighter-rouge">GraphQL::Dataloader::Source</code>. A Source <em>must</em> implement <code class="language-plaintext highlighter-rouge">def fetch(keys)</code> to return a list of objects, one for each of the given keys. A source <em>may</em> implement <code class="language-plaintext highlighter-rouge">def initialize(...)</code> to accept other batching parameters.</p>

<p>Sources will receive two kinds of inputs from <code class="language-plaintext highlighter-rouge">GraphQL::Dataloader</code>:</p>

<ul>
  <li>
    <p><em>keys</em>, which correspond to objects requested by the application.</p>

    <p>Keys are passed to <code class="language-plaintext highlighter-rouge">def fetch(keys)</code>, which must return an object (or <code class="language-plaintext highlighter-rouge">nil</code>) for each of <code class="language-plaintext highlighter-rouge">keys</code>, in the same order as <code class="language-plaintext highlighter-rouge">keys</code>.</p>

    <p>Under the hood, each Source instance maintains a <code class="language-plaintext highlighter-rouge">key =&gt; object</code> cache.</p>
  </li>
  <li>
    <p><em>batch parameters</em>, which are the basis of batched groups. For example, if you’re loading records from different database tables, the table name would be a batch parameter.</p>

    <p>Batch parameters are given to <code class="language-plaintext highlighter-rouge">dataloader.with(source_class, *batch_parameters)</code>, and the default is <em>no batch parameters</em>. When you define a source, you should add the batch parameters to <code class="language-plaintext highlighter-rouge">def initialize(...)</code> and store them in instance variables.</p>

    <p>(<code class="language-plaintext highlighter-rouge">dataloader.with(source_class, *batch_parameters)</code> returns an instance of <code class="language-plaintext highlighter-rouge">source_class</code> with the given batch parameters – but it might be an instance which was cached by <code class="language-plaintext highlighter-rouge">dataloader</code>.)</p>

    <p>Additionally, batch parameters are used to de-duplicate Source initializations during a query run. <code class="language-plaintext highlighter-rouge">.with(...)</code> calls that have the same batch parameters will use the same Source instance under the hood. To customize how Sources are de-duplicated, see <a href="/api-doc/2.5.7/GraphQL/Dataloader/Source#batch_key_for-class_method" target="_blank" title="API docs for GraphQL::Dataloader::Source.batch_key_for"><code>GraphQL::Dataloader::Source.batch_key_for</code></a>.</p>
  </li>
</ul>

<h2 id="example-loading-strings-from-redis-by-key">Example: Loading Strings from Redis by Key</h2>

<p>The simplest source might fetch values based on their keys. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/sources/redis_string.rb</span>
<span class="k">class</span> <span class="nc">Sources::RedisString</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Dataloader</span><span class="o">::</span><span class="no">Source</span>
  <span class="no">REDIS</span> <span class="o">=</span> <span class="no">Redis</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
    <span class="c1"># Redis's `mget` will return a value for each key with a `nil` for any not-found key.</span>
    <span class="no">REDIS</span><span class="p">.</span><span class="nf">mget</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This loader could be used in GraphQL like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">some_string</span> <span class="o">=</span> <span class="n">dataloader</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="no">Sources</span><span class="o">::</span><span class="no">RedisString</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="s2">"some_key"</span><span class="p">)</span>
</code></pre></div></div>

<p>Calls to <code class="language-plaintext highlighter-rouge">.load(key)</code> will be batched, and when <code class="language-plaintext highlighter-rouge">GraphQL::Dataloader</code> can’t go any further, it will dispatch a call to <code class="language-plaintext highlighter-rouge">def fetch(keys)</code> above.</p>

<h2 id="example-loading-activerecord-objects-by-id">Example: Loading ActiveRecord Objects by ID</h2>

<p>To fetch ActiveRecord objects by ID, the source should also accept the <em>model class</em> as a batching parameter. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/sources/active_record_object.rb</span>
<span class="k">class</span> <span class="nc">Sources::ActiveRecordObject</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Dataloader</span><span class="o">::</span><span class="no">Source</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">model_class</span><span class="p">)</span>
    <span class="vi">@model_class</span> <span class="o">=</span> <span class="n">model_class</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">records</span> <span class="o">=</span> <span class="vi">@model_class</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">ids</span><span class="p">)</span>
    <span class="c1"># return a list with `nil` for any ID that wasn't found</span>
    <span class="n">ids</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">id</span><span class="o">|</span> <span class="n">records</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="p">.</span><span class="nf">id</span> <span class="o">==</span> <span class="nb">id</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This source could be used for any <code class="language-plaintext highlighter-rouge">model_class</code>, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">author</span> <span class="o">=</span> <span class="n">dataloader</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="no">Sources</span><span class="o">::</span><span class="no">ActiveRecordObject</span><span class="p">,</span> <span class="o">::</span><span class="no">User</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">post</span> <span class="o">=</span> <span class="n">dataloader</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="no">Sources</span><span class="o">::</span><span class="no">ActiveRecordObject</span><span class="p">,</span> <span class="o">::</span><span class="no">Post</span><span class="p">).</span><span class="nf">load</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="example-batched-calculations">Example: Batched Calculations</h2>

<p>Besides fetching objects, Sources can return values from batched calculations. For example, a system could batch up checks for who a user follows:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># for a given user, batch checks to see whether this user follows another user.</span>
<span class="c1"># (The default `user.followings.where(followed_user_id: followed).exists?` would cause N+1 queries.)</span>
<span class="k">class</span> <span class="nc">Sources::UserFollowingExists</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Dataloader</span><span class="o">::</span><span class="no">Source</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
    <span class="vi">@user</span> <span class="o">=</span> <span class="n">user</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span>
    <span class="c1"># Prepare a `SELECT id FROM users WHERE handle IN(...)` statement</span>
    <span class="n">user_ids</span> <span class="o">=</span> <span class="o">::</span><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">handle: </span><span class="n">handles</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
    <span class="c1"># And use it to filter this user's followings:</span>
    <span class="n">followings</span> <span class="o">=</span> <span class="vi">@user</span><span class="p">.</span><span class="nf">followings</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">followed_user_id: </span><span class="n">user_ids</span><span class="p">)</span>
    <span class="c1"># Now, for followings that _actually_ hit a user, get the handles for those users:</span>
    <span class="n">followed_users</span> <span class="o">=</span> <span class="o">::</span><span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">followings</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:followed_user_id</span><span class="p">))</span>
    <span class="c1"># Finally, return a result set, with one entry (true or false) for each of the given `handles`</span>
    <span class="n">handles</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="o">|</span> <span class="o">!!</span><span class="n">followed_users</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">u</span><span class="o">|</span> <span class="n">u</span><span class="p">.</span><span class="nf">handle</span> <span class="o">==</span> <span class="n">h</span> <span class="p">}}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It could be used like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">is_following</span> <span class="o">=</span> <span class="n">dataloader</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="no">Sources</span><span class="o">::</span><span class="no">UserFollowingExists</span><span class="p">,</span> <span class="n">context</span><span class="p">[</span><span class="ss">:viewer</span><span class="p">]).</span><span class="nf">load</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
</code></pre></div></div>

<p>After all requests were batched, <code class="language-plaintext highlighter-rouge">#fetch</code> will return a Boolean result to <code class="language-plaintext highlighter-rouge">is_following</code>.</p>

<h2 id="example-loading-in-a-background-thread">Example: Loading in a background thread</h2>

<p>Inside <code class="language-plaintext highlighter-rouge">Source#fetch(keys)</code>, you can call <code class="language-plaintext highlighter-rouge">dataloader.yield</code> to return control to the Dataloader. This way, it will proceed loading other Sources (if there are any), then return the source that yielded.</p>

<p>A simple example, spinning up a new Thread:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
  <span class="c1"># spin up some work in a background thread</span>
  <span class="n">thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
    <span class="n">fetch_external_data</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1"># return control to the dataloader</span>
  <span class="n">dataloader</span><span class="p">.</span><span class="nf">yield</span>
  <span class="c1"># at this point,</span>
  <span class="c1"># the dataloader has tried everything else and come back to this source,</span>
  <span class="c1"># so block if necessary:</span>
  <span class="n">thread</span><span class="p">.</span><span class="nf">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>See the <a href="/dataloader/parallelism">parallelism guide</a> for details about this approach.</p>

<h2 id="filling-the-dataloader-cache">Filling the Dataloader Cache</h2>

<p>If you load records from the database, you can use them to populate a source’s cache by using <a href="/api-doc/2.5.7/GraphQL/Dataloader/Source#merge-instance_method" target="_blank" title="API docs for GraphQL::Dataloader::Source#merge"><code>Dataloader::Source#merge</code></a>. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Build a `{ key =&gt; value }` map to populate the cache</span>
<span class="n">comments_by_id</span> <span class="o">=</span> <span class="n">post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">each_with_object</span><span class="p">({})</span> <span class="p">{</span> <span class="o">|</span><span class="n">comment</span><span class="p">,</span> <span class="nb">hash</span><span class="o">|</span> <span class="nb">hash</span><span class="p">[</span><span class="n">comment</span><span class="p">.</span><span class="nf">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">comment</span> <span class="p">}</span>
<span class="c1"># Merge the map into the source's cache</span>
<span class="n">dataloader</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="no">Sources</span><span class="o">::</span><span class="no">ActiveRecordObject</span><span class="p">,</span> <span class="no">Comment</span><span class="p">).</span><span class="nf">merge</span><span class="p">(</span><span class="n">comments_by_id</span><span class="p">)</span>
</code></pre></div></div>

<p>After that, any calls to <code class="language-plaintext highlighter-rouge">.load(id)</code> will use those already-loaded records if they’re available.</p>

<h2 id="de-duplicating-equivalent-objects">De-duplicating equivalent objects</h2>

<p>Sometimes, <em>different</em> objects in the application should load the same object from <code class="language-plaintext highlighter-rouge">fetch</code>. You can customize this behavior by implementing <code class="language-plaintext highlighter-rouge">def result_key_for(key)</code> in your application. For example, to map records from your ORM to their database ID:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Load the `created_by` person for a record from our database</span>
<span class="k">class</span> <span class="nc">CreatedBySource</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Dataloader</span><span class="o">::</span><span class="no">Source</span>
  <span class="k">def</span> <span class="nf">result_key_for</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">key</span><span class="p">.</span><span class="nf">id</span> <span class="c1"># Use the record's ID to deduplicate different `.load` calls</span>
  <span class="k">end</span>

  <span class="c1"># Fetch a `person` for each of `records`, based on their created_by_id</span>
  <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
    <span class="no">PersonService</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="n">records</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:created_by_id</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In this case, <code class="language-plaintext highlighter-rouge">records</code> will include the <em>first</em> object for each unique <code class="language-plaintext highlighter-rouge">record.id</code> – subsequent records with the same <code class="language-plaintext highlighter-rouge">.id</code> will be assumed to be duplicates. Under the hood, the <code class="language-plaintext highlighter-rouge">Source</code> will cache the result based on the record’s <code class="language-plaintext highlighter-rouge">id</code>.</p>

<p>Alternatively, you could use this to make the <code class="language-plaintext highlighter-rouge">Source</code> retain each incoming object, even when they would <em>otherwise</em> be treated as duplicates. (This would come in handy when you need <code class="language-plaintext highlighter-rouge">def fetch</code> to mutate each object). For example, to treat <em>every</em> incoming object as distinct:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">result_key_for</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
  <span class="n">record</span><span class="p">.</span><span class="nf">object_id</span> <span class="c1"># even if the records are equivalent, handle each distinct Ruby object separately</span>
<span class="k">end</span>
</code></pre></div></div>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/dataloader/sources.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Sources">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
  function navigateToSelected(selectElement) {
    var nextPage = selectElement.selectedOptions[0].dataset["target"]
    document.location = nextPage
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
    <script>
      detectDarkTheme(false) // do it again to update the images
    </script>
  </body>
</html>
