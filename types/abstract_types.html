<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Interface and Union Types</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/1.8.0/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#types-guides">Types</a>
  &raquo; Interface and Union Types
</p>



<h1 class="guide-header">Interface and Union Types</h1>
<div class="guide-container">
  <h2 id="type-resolution">Type Resolution</h2>

<p>When we have a member of an interface or union, which object type should we use? Your GraphQL schema may need help from you, which you can provide as <code class="highlighter-rouge">resolve_type(type, obj, ctx)</code>.</p>

<p>Provide <code class="highlighter-rouge">resolve_type</code> as an object that responds to <code class="highlighter-rouge">#call</code>, for example, a <code class="highlighter-rouge">Proc</code> literal:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">resolve_type</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>or, a module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ResolveType</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">call</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>


<span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">resolve_type</span> <span class="no">ResolveType</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="type-level-resolution-hooks">Type-Level Resolution Hooks</h2>

<p>In addition to a single, top-level <code class="highlighter-rouge">resolve_type</code> function, you can provide type-level functions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyUnion</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">UnionType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">resolve_type</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># resolve `obj` as a member of `MyUnion`</span>
  <span class="p">}</span>
<span class="k">end</span>

<span class="no">MyInterface</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">InterfaceType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="n">resolve_type</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># resolve `obj` as a member of `MyInterface`</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Keep the schema-level <code class="highlighter-rouge">resolve_type</code> function: these type-level functions take priority over the schema-level function.</p>

<h2 id="orphan-types">Orphan Types</h2>

<p>The schema builds its type system by traversing its data entry points. In some cases, types should be present in the schema but aren’t available via traversal, so you have to add them yourself.</p>

<p>The clearest case of this is when a type implements an interface, but isn’t a return type of any other field. Since it’s not the return type of a field, it might not be found by traversal, so you can add it in <code class="highlighter-rouge">orphan_types</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="c1"># Make sure these types are present in the schema:</span>
  <span class="n">orphan_types</span> <span class="p">[</span><span class="no">AudioType</span><span class="p">,</span> <span class="no">VideoType</span><span class="p">,</span> <span class="no">ImageType</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>It’s OK to add a type to <code class="highlighter-rouge">orphan_types</code> even if it’s already in the schema.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/types/abstract_types.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Interface and Union Types">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
