<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL Enterprise - Object Cache - Caching Results</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400,700" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <script>
      function detectDarkTheme(toggle) {
        var prefersDarkSchemeSetting = localStorage.getItem("prefersDarkScheme")
        if (prefersDarkSchemeSetting == null) {
          prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        } else {
          prefersDarkScheme = prefersDarkSchemeSetting == "true"
        }

        if (toggle) {
          if (prefersDarkScheme) {
            prefersDarkScheme = false
            localStorage.setItem("prefersDarkScheme", "false")
          } else {
            prefersDarkScheme = true
            localStorage.setItem("prefersDarkScheme", "true")
          }
        }

        if (prefersDarkScheme) {
          document.body.classList.add('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby-dark.png"
          })
        } else {
          document.body.classList.remove('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby.png"
          })
        }
      }

      detectDarkTheme(false)
    </script>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img class="graphql-ruby-img" src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <div class="nav-links">
            <a href="/getting_started">Get Started</a>
            <a href="/guides">Guides</a>
            <a href="/api-doc/2.4.8/">API</a>
            <a href="https://buttondown.email/graphql-ruby">Newsletter</a>
            <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
            <a href="https://graphql.pro">Upgrade to Pro</a>
            <input
              class="search-input"
              onkeyup="GraphQLRubySearch.run(this)"
              type="text"
              placeholder="Search the docs..."
            />
            <a href="#" onclick="event.preventDefault(); detectDarkTheme(true)" class="dark-theme-button"></a>
          </div>
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container  fullwidth ">
      <ul class="breadcrumb">
  <li><a href="/guides">Guides</a></li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/schema/definition.html">Schema</option>
      
        <option  data-target="/queries/executing_queries.html">Queries</option>
      
        <option  data-target="/type_definitions/objects.html">Type Definitions</option>
      
        <option  data-target="/authorization/overview.html">Authorization</option>
      
        <option  data-target="/fields/introduction.html">Fields</option>
      
        <option  data-target="/mutations/mutation_root.html">Mutations</option>
      
        <option  data-target="/errors/overview.html">Errors</option>
      
        <option  data-target="/pagination/overview.html">Pagination</option>
      
        <option  data-target="/relay/range_add.html">Relay</option>
      
        <option  data-target="/dataloader/overview.html">Dataloader</option>
      
        <option  data-target="/subscriptions/overview.html">Subscriptions</option>
      
        <option  data-target="/pro/home.html">GraphQL Pro</option>
      
        <option  data-target="/operation_store/overview.html">GraphQL Pro - OperationStore</option>
      
        <option  data-target="/defer/overview.html">GraphQL Pro - Defer</option>
      
        <option  data-target="/limiters/overview.html">GraphQL Enterprise - Rate Limiters</option>
      
        <option  selected data-target="/object_cache/overview.html">GraphQL Enterprise - Object Cache</option>
      
        <option  data-target="/changesets/overview.html">GraphQL Enterprise - Changesets</option>
      
        <option  data-target="/javascript_client/overview.html">JavaScript Client</option>
      
        <option  data-target="/language_tools/visitor.html">Language Tools</option>
      
        <option  data-target="/testing/overview.html">Testing</option>
      
        <option  data-target="/development.html">Other</option>
      
    </select>
  </li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/object_cache/overview.html">GraphQL ObjectCache</option>
      
        <option  data-target="/object_cache/schema_setup.html">Schema Setup</option>
      
        <option  selected data-target="/object_cache/caching.html">Caching Results</option>
      
        <option  data-target="/object_cache/memcached.html">Dalli Configuration</option>
      
        <option  data-target="/object_cache/redis.html">Redis Configuration</option>
      
        <option  data-target="/object_cache/runtime_considerations.html">Runtime Considerations</option>
      
    </select>
  </li>
</ul>



  <div class="enterprise-header">
    <p>
      <strong>🌟 Enterprise Feature 🌟</strong>
      <span style="font-style: italic;">
        This feature is bundled with <a href="https://graphql.pro/enterprise">GraphQL-Enterprise</a>.
      </span>
    </p>
  </div>

<h1 class="guide-header">Caching Results</h1>
<div class="guide-table-of-contents"><div class="table-of-contents">
  <h3 class="contents-header">Contents</h3>
  <ol class='contents-list'><li class='contents-entry'><a href='#cacheable-true-false'><code>cacheable(true|false)</code>
</a></li><li class='contents-entry'><a href='#public'><code>public:</code>
</a></li><li class='contents-entry'><a href='#ttl'><code>ttl:</code>
</a></li><li class='contents-entry'><a href='#caching-lists-and-connections'>Caching lists and connections
</a><ol class='contents-list'><li class='contents-entry'><a href='#has_many-lists'><code>has_many</code> lists
</a></li><li class='contents-entry'><a href='#top-level-lists'>Top-level lists
</a></li><li class='contents-entry'><a href='#connections'>Connections
</a></li></ol></li><li class='contents-entry'><a href='#caching-introspection'>Caching Introspection
</a></li><li class='contents-entry'><a href='#object-dependencies'>Object Dependencies
</a></li></ol>
</div>
</div>
<div class="guide-container">
  <p><code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::ObjectCache</code> supports several different caching configurations for objects and fields. To get started, include the extension in your base object class and base field class and use <code class="language-plaintext highlighter-rouge">cacheable(...)</code> to set up the default cache behavior:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_object.rb</span>
<span class="k">class</span> <span class="nc">Types::BaseObject</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Object</span>
  <span class="kp">include</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">ObjectIntegration</span>
  <span class="n">field_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseField</span>
  <span class="n">cacheable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># see below</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_field.rb</span>
<span class="k">class</span> <span class="nc">Types::BaseField</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Field</span>
  <span class="kp">include</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">FieldIntegration</span>
  <span class="n">cacheable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># see below</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Also, make sure your base interface module is using your field class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/types/base_interface.md</span>
<span class="k">module</span> <span class="nn">Types::BaseInterface</span>
 <span class="n">field_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseField</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Field caching can be configured per-field, too, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:latest_update</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">Update</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">cacheable: </span><span class="p">{</span> <span class="ss">ttl: </span><span class="mi">60</span> <span class="p">}</span>

<span class="n">field</span> <span class="ss">:random_number</span><span class="p">,</span> <span class="no">Int</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span><span class="p">,</span> <span class="ss">cacheable: </span><span class="kp">false</span>
</code></pre></div></div>

<p>Only <em>queries</em> are cached. <code class="language-plaintext highlighter-rouge">ObjectCache</code> skips mutations and subscriptions altogether.</p>

<h2 id="cacheabletruefalse"><code class="language-plaintext highlighter-rouge">cacheable(true|false)</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(true)</code> means that the configured type or field may be stored in the cache until its cache fingerprint changes. It also defaults to <code class="language-plaintext highlighter-rouge">public: false</code>, meaning that clients will <em>not</em> share cached responses. See <a href="#public"><code class="language-plaintext highlighter-rouge">public:</code></a> below for more about this option.</p>

<p><code class="language-plaintext highlighter-rouge">cacheable(false)</code> disables caching for the configured type or field. Any query that includes this type or field will neither check for an already-cached value nor update the cache with its result.</p>

<h2 id="public"><code class="language-plaintext highlighter-rouge">public:</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(public: false)</code> means that a type or field may be <em>cached</em>, but <a href="/object_cache/schema_setup#context-fingerprint"><code class="language-plaintext highlighter-rouge">Schema.private_context_fingerprint_for(ctx)</code></a> should be included in its cache key. In practice, this means that each client can have its own cached responses. Any query that contains a <code class="language-plaintext highlighter-rouge">cacheable(public: false)</code> type or field will use a private cache key.</p>

<p><code class="language-plaintext highlighter-rouge">cacheable(public: true)</code> means that cached values from this type or field may be shared by <em>all</em> clients. Use this for public-facing data which is the same for all viewers. Queries that include <em>only</em> <code class="language-plaintext highlighter-rouge">public: true</code> types and fields will not include <code class="language-plaintext highlighter-rouge">Schema.private_context_fingerprint_for(ctx)</code> in their cache keys. That way their responses will be shared by all clients who request them.</p>

<h2 id="ttl"><code class="language-plaintext highlighter-rouge">ttl:</code></h2>

<p><code class="language-plaintext highlighter-rouge">cacheable(ttl: seconds)</code> expires any cached value after the given number of seconds, regardless of cache fingerprint. <code class="language-plaintext highlighter-rouge">ttl:</code> shines in a few cases:</p>

<ul>
  <li>Objects that can’t reliably generate a fingerprint value (for example, they have no <code class="language-plaintext highlighter-rouge">.updated_at</code> timestamp). In this case, a conservative <code class="language-plaintext highlighter-rouge">ttl</code> may be the only option for cache expiration.</li>
  <li>Or, root-level fields that should be expired after a certain amount of time. The root-level <code class="language-plaintext highlighter-rouge">Query</code> often has <em>no</em> backing object, so it won’t have a cache fingerprint, either. Adding <code class="language-plaintext highlighter-rouge">cacheable: { ttl: ... }</code> to root level fields will provide some caching along with a guarantee about when they’ll be expired.</li>
  <li>Or, list responses that may be difficult to invalidate properly (see below).</li>
</ul>

<p>Under the hood, <code class="language-plaintext highlighter-rouge">ttl:</code> is implemented with Redis’s <code class="language-plaintext highlighter-rouge">EXPIRE</code>.</p>

<h2 id="caching-lists-and-connections">Caching lists and connections</h2>

<p>Lists and connections require a little extra consideration. By default, each <em>item</em> in a list is registered with the cache, but when new items are created, they are unknown to the cache and therefore don’t invalidate the cached result. There are two main approaches to address this.</p>

<h3 id="has_many-lists"><code class="language-plaintext highlighter-rouge">has_many</code> lists</h3>

<p>In order to effectively bust the cache, items that belong to the list of “parent” object should <strong>update the parent</strong> (eg, Rails <code class="language-plaintext highlighter-rouge">.touch</code>) whenever they’re created, destroyed, or updated. For example, if there’s a list of players on a team:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="n">team</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">players</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">totalCount</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>None of the <em>specific</em> <code class="language-plaintext highlighter-rouge">Player</code>s will be part of the cached response, but the <code class="language-plaintext highlighter-rouge">Team</code> will be. To properly invalidate the cache, the <code class="language-plaintext highlighter-rouge">Team</code>’s <code class="language-plaintext highlighter-rouge">updated_at</code> (or other cache key) should be updated whenever a <code class="language-plaintext highlighter-rouge">Player</code> is added or removed from the <code class="language-plaintext highlighter-rouge">Team</code>.</p>

<p>If a list may be sorted, then updates to <code class="language-plaintext highlighter-rouge">Player</code>s should also update the <code class="language-plaintext highlighter-rouge">Team</code> so that any sorted results in the cache are invalidated, too. Alternatively (or additionally), you could use a <code class="language-plaintext highlighter-rouge">ttl:</code> to expire cached results after a certain duration, just to be sure that results are eventually expired.</p>

<p>With Rails, you can accomplish this with:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># update the team whenever a player is saved or destroyed:</span>
  <span class="n">belongs_to</span> <span class="ss">:team</span><span class="p">,</span> <span class="ss">touch: </span><span class="kp">true</span>
</code></pre></div></div>

<h3 id="top-level-lists">Top-level lists</h3>

<p>For <code class="language-plaintext highlighter-rouge">ActiveRecord::Relation</code>s <em>without</em> a “parent” object, you can use <code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::ObjectCache::CacheableRelation</code> to make a synthetic cache entry for the <em>whole</em> relation. To use this class, make a subclass and implement <code class="language-plaintext highlighter-rouge">def items</code>, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AllTeams</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">CacheableRelation</span>
  <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="ss">division: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="n">teams</span> <span class="o">=</span> <span class="no">Team</span><span class="p">.</span><span class="nf">all</span>
    <span class="k">if</span> <span class="n">division</span>
      <span class="n">teams</span> <span class="o">=</span> <span class="n">teams</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">division: </span><span class="n">division</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">teams</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, in your resolver, use your new class to retrieve the items:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Query</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Object</span>
  <span class="n">field</span> <span class="ss">:teams</span><span class="p">,</span> <span class="no">Team</span><span class="p">.</span><span class="nf">connection_type</span> <span class="k">do</span>
    <span class="n">argument</span> <span class="ss">:division</span><span class="p">,</span> <span class="no">Division</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">teams</span><span class="p">(</span><span class="ss">division: </span><span class="kp">nil</span><span class="p">)</span>
    <span class="no">AllTeams</span><span class="p">.</span><span class="nf">items_for</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">division: </span><span class="n">division</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you’re using <a href="/api-doc/2.4.8/GraphQL/Schema/Resolver" target="_blank" title="API docs for GraphQL::Schema::Resolver"><code>GraphQL::Schema::Resolver</code></a>, you’d call <code class="language-plaintext highlighter-rouge">.items_for</code> slightly differently:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="ss">division: </span><span class="kp">nil</span><span class="p">)</span>
  <span class="c1"># use `context[:current_object]` to get the GraphQL::Schema::Object instance whose field is being resolved</span>
  <span class="no">AllTeams</span><span class="p">.</span><span class="nf">items_for</span><span class="p">(</span><span class="n">context</span><span class="p">[</span><span class="ss">:current_object</span><span class="p">],</span> <span class="ss">division: </span><span class="n">division</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Finally, you’ll need to handle <code class="language-plaintext highlighter-rouge">CacheableRelation</code>s in your object identification methods, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">id_from_object</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">object</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">CacheableRelation</span><span class="p">)</span>
      <span class="n">object</span><span class="p">.</span><span class="nf">id</span>
    <span class="k">else</span>
      <span class="c1"># The rest of your id_from_object logic here...</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">object_from_id</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cacheable_rel</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">ObjectCache</span><span class="o">::</span><span class="no">CacheableRelation</span><span class="p">.</span><span class="nf">find?</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span>
      <span class="n">cacheable_rel</span>
    <span class="k">else</span>
      <span class="c1"># The rest of your object_from_id logic here...</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">AllTeams</code> implements several methods to support caching:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">#id</code> creates a cache-friendly, stable global ID</li>
  <li><code class="language-plaintext highlighter-rouge">#to_param</code> creates a cache fingerprint (using Rails’s <code class="language-plaintext highlighter-rouge">#cache_key</code> under the hood)</li>
  <li><code class="language-plaintext highlighter-rouge">.find?</code> retrieves the list based on its ID</li>
</ul>

<p>This way, if a <code class="language-plaintext highlighter-rouge">Team</code> is created, the cached result will be invalidated and a fresh result will be created.</p>

<p>Alternatively (or additionally), you could use a <code class="language-plaintext highlighter-rouge">ttl:</code> to expire cached results after a certain duration, just to be sure that results are eventually expired.</p>

<h3 id="connections">Connections</h3>

<p>By default, connection-related objects (like <code class="language-plaintext highlighter-rouge">*Connection</code> and <code class="language-plaintext highlighter-rouge">*Edge</code> types) “inherit” cacheability from their node types. You can override this in your base classes as long as <code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::ObjectCache::ObjectIntegration</code> is included in the inheritance chain somewhere.</p>

<h2 id="caching-introspection">Caching Introspection</h2>

<p>By default, introspection fields are considered <em>public</em> for all queries. This means that they are considered cacheable and their results will be reused for any clients who request them. When <a href="/object_cache/schema_setup#add-the-cache">adding the ObjectCache to your schema</a>, you can provide some options to customize this behavior:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: { public: false, ... }</code> to use <a href="#public"><code class="language-plaintext highlighter-rouge">public: false</code></a> for all introspection fields. Use this if you hide schema members for some clients.</li>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: false</code> to completely disable caching on introspection fields.</li>
  <li><code class="language-plaintext highlighter-rouge">cache_introspection: { ttl: ..., ... }</code> to set a <a href="#ttl">ttl</a> (in seconds) for introspection fields.</li>
</ul>

<h2 id="object-dependencies">Object Dependencies</h2>

<p>By default, the <code class="language-plaintext highlighter-rouge">object</code> of a GraphQL Object type is used for caching the fields selected on that object. But, you can specify what object (or objects) should be used to check the cache by implementing <code class="language-plaintext highlighter-rouge">def self.cache_dependencies_for(object, context)</code> in your type definition. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Types::Player</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cache_dependencies_for</span><span class="p">(</span><span class="n">player</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="c1"># we update the team's timestamp whenever player details change,</span>
    <span class="c1"># so ignore the `player` for caching purposes</span>
    <span class="n">player</span><span class="p">.</span><span class="nf">team</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Use this to:</p>

<ul>
  <li>improve performance when caching lists of children that belong to a parent object</li>
  <li>register other objects with the ObjectCache when running a query. (<code class="language-plaintext highlighter-rouge">cacheable_object(obj)</code> or <code class="language-plaintext highlighter-rouge">def self.object_fingerprint_for</code> can also be used in this case.)</li>
</ul>

<p>If this method returns an <code class="language-plaintext highlighter-rouge">Array</code>, each object in the array will be registered with the cache.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/object_cache/caching.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Caching Results">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
  function navigateToSelected(selectElement) {
    var nextPage = selectElement.selectedOptions[0].dataset["target"]
    document.location = nextPage
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
    <script>
      detectDarkTheme(false) // do it again to update the images
    </script>
  </body>
</html>
