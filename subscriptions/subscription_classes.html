<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Subscription Classes</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400,700" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <script>
      function detectDarkTheme(toggle) {
        var prefersDarkSchemeSetting = localStorage.getItem("prefersDarkScheme")
        if (prefersDarkSchemeSetting == null) {
          prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        } else {
          prefersDarkScheme = prefersDarkSchemeSetting == "true"
        }

        if (toggle) {
          if (prefersDarkScheme) {
            prefersDarkScheme = false
            localStorage.setItem("prefersDarkScheme", "false")
          } else {
            prefersDarkScheme = true
            localStorage.setItem("prefersDarkScheme", "true")
          }
        }

        if (prefersDarkScheme) {
          document.body.classList.add('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby-dark.png"
          })
        } else {
          document.body.classList.remove('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby.png"
          })
        }
      }

      detectDarkTheme(false)
    </script>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img class="graphql-ruby-img" src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <div class="nav-links">
            <a href="/getting_started">Get Started</a>
            <a href="/guides">Guides</a>
            <a href="/api-doc/2.5.5/">API</a>
            <a href="https://buttondown.email/graphql-ruby">Newsletter</a>
            <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
            <a href="https://graphql.pro">Upgrade to Pro</a>
            <input
              class="search-input"
              onkeyup="GraphQLRubySearch.run(this)"
              type="text"
              placeholder="Search the docs..."
            />
            <a href="#" onclick="event.preventDefault(); detectDarkTheme(true)" class="dark-theme-button"></a>
          </div>
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container  fullwidth ">
      <ul class="breadcrumb">
  <li><a href="/guides">Guides</a></li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/schema/definition.html">Schema</option>
      
        <option  data-target="/queries/executing_queries.html">Queries</option>
      
        <option  data-target="/type_definitions/objects.html">Type Definitions</option>
      
        <option  data-target="/authorization/overview.html">Authorization</option>
      
        <option  data-target="/fields/introduction.html">Fields</option>
      
        <option  data-target="/mutations/mutation_root.html">Mutations</option>
      
        <option  data-target="/errors/overview.html">Errors</option>
      
        <option  data-target="/pagination/overview.html">Pagination</option>
      
        <option  data-target="/relay/range_add.html">Relay</option>
      
        <option  data-target="/dataloader/overview.html">Dataloader</option>
      
        <option  selected data-target="/subscriptions/overview.html">Subscriptions</option>
      
        <option  data-target="/pro/home.html">GraphQL Pro</option>
      
        <option  data-target="/operation_store/overview.html">GraphQL Pro - OperationStore</option>
      
        <option  data-target="/defer/overview.html">GraphQL Pro - Defer</option>
      
        <option  data-target="/limiters/overview.html">GraphQL Enterprise - Rate Limiters</option>
      
        <option  data-target="/object_cache/overview.html">GraphQL Enterprise - Object Cache</option>
      
        <option  data-target="/changesets/overview.html">GraphQL Enterprise - Changesets</option>
      
        <option  data-target="/javascript_client/overview.html">JavaScript Client</option>
      
        <option  data-target="/language_tools/visitor.html">Language Tools</option>
      
        <option  data-target="/testing/overview.html">Testing</option>
      
        <option  data-target="/development.html">Other</option>
      
    </select>
  </li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/subscriptions/overview.html">Overview</option>
      
        <option  selected data-target="/subscriptions/subscription_classes.html">Subscription Classes</option>
      
        <option  data-target="/subscriptions/subscription_type.html">Subscription Type</option>
      
        <option  data-target="/subscriptions/triggers.html">Triggers</option>
      
        <option  data-target="/subscriptions/broadcast.html">Broadcasts</option>
      
        <option  data-target="/subscriptions/implementation.html">Implementation</option>
      
        <option  data-target="/subscriptions/action_cable_implementation.html">Action Cable Implementation</option>
      
        <option  data-target="/subscriptions/pusher_implementation.html">Pusher Implementation</option>
      
        <option  data-target="/subscriptions/ably_implementation.html">Ably Implementation</option>
      
        <option  data-target="/subscriptions/multi_tenant.html">Multi-Tenant</option>
      
    </select>
  </li>
</ul>



<h1 class="guide-header">Subscription Classes</h1>
<div class="guide-table-of-contents"><div class="table-of-contents">
  <h3 class="contents-header">Contents</h3>
  <ol class='contents-list'><li class='contents-entry'><a href='#add-a-base-class'>Add a base class
</a></li><li class='contents-entry'><a href='#extend-the-base-class-and-hook-it-up'>Extend the base class and hook it up
</a></li><li class='contents-entry'><a href='#arguments'>Arguments
</a></li><li class='contents-entry'><a href='#fields'>Fields
</a></li><li class='contents-entry'><a href='#scope'>Scope
</a></li><li class='contents-entry'><a href='#check-permissions-with-authorized'>Check Permissions with #authorized?
</a></li><li class='contents-entry'><a href='#initial-subscription-with-subscribe'>Initial Subscription with #subscribe
</a><ol class='contents-list'><li class='contents-entry'><a href='#adding-an-initial-response'>Adding an Initial Response
</a></li></ol></li><li class='contents-entry'><a href='#subsequent-updates-with-update'>Subsequent Updates with #update
</a><ol class='contents-list'><li class='contents-entry'><a href='#skipping-subscription-updates'>Skipping subscription updates
</a></li><li class='contents-entry'><a href='#returning-a-different-object-for-subscription-updates'>Returning a different object for subscription updates
</a></li></ol></li><li class='contents-entry'><a href='#terminating-the-subscription-with-unsubscribe'>Terminating the subscription with #unsubscribe
</a></li><li class='contents-entry'><a href='#extras'>Extras
</a></li></ol>
</div>
</div>
<div class="guide-container">
  <p>You can extend <a href="/api-doc/2.5.5/GraphQL/Schema/Subscription" target="_blank" title="API docs for GraphQL::Schema::Subscription"><code>GraphQL::Schema::Subscription</code></a> to create fields that can be subscribed to.</p>

<p>These classes support several behaviors:</p>

<ul>
  <li><a href="#check-permissions-with-authorized">Authorizing</a> (or rejecting) initial subscription requests and subsequent updates</li>
  <li>Returning values for <a href="#initial-subscription-with-subscribe">initial subscription requests</a></li>
  <li><a href="#terminating-the-subscription-with-unsubscribe">Unsubscribing</a> from the server</li>
  <li>Implicitly <a href="#scope">scoping updates</a>, to direct data to the right subscriber</li>
  <li><a href="#subsequent-updates-with-update">Skipping updates</a> for certain clients (eg, don’t send updates to the person who triggered the event)</li>
</ul>

<p>Continue reading to set up subscription classes.</p>

<h2 id="add-a-base-class">Add a base class</h2>

<p>First, add a base class for your application. You can hook up your base classes there:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/subscriptions/base_subscription.rb</span>
<span class="k">class</span> <span class="nc">Subscriptions::BaseSubscription</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Subscription</span>
  <span class="c1"># Hook up base classes</span>
  <span class="n">object_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseObject</span>
  <span class="n">field_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseField</span>
  <span class="n">argument_class</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseArgument</span>
<span class="k">end</span>
</code></pre></div></div>

<p>(This base class is a lot like the <a href="/mutations/mutation_classes">mutation base class</a>. They’re both subclasses of <a href="/api-doc/2.5.5/GraphQL/Schema/Resolver" target="_blank" title="API docs for GraphQL::Schema::Resolver"><code>GraphQL::Schema::Resolver</code></a>.)</p>

<h2 id="extend-the-base-class-and-hook-it-up">Extend the base class and hook it up</h2>

<p>Define a class for each subscribable event in your system. For example, if you run a chat room, you might publish events whenever messages are posted in a room:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/subscriptions/message_was_posted.rb</span>
<span class="k">class</span> <span class="nc">Subscriptions::MessageWasPosted</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, hook up the new class to the <a href="/subscriptions/subscription_type">Subscription root type</a> with the <code class="language-plaintext highlighter-rouge">subscription:</code> option:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Types::SubscriptionType</span> <span class="o">&lt;</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseObject</span>
  <span class="n">field</span> <span class="ss">:message_was_posted</span><span class="p">,</span> <span class="ss">subscription: </span><span class="no">Subscriptions</span><span class="o">::</span><span class="no">MessageWasPosted</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, it will be accessible as:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">messageWasPosted</span><span class="p">(</span><span class="n">roomId</span><span class="p">:</span><span class="w"> </span><span class="s2">"abcd"</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c"># ...</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="arguments">Arguments</h2>

<p>Subscription fields take <a href="/fields/arguments">arguments</a> just like normal fields. They also accept a <a href="/mutations/mutation_classes#auto-loading-arguments"><code class="language-plaintext highlighter-rouge">loads:</code> option</a> just like mutations. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::MessageWasPosted</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
  <span class="c1"># `room_id` loads a `room`</span>
  <span class="n">argument</span> <span class="ss">:room_id</span><span class="p">,</span> <span class="no">ID</span><span class="p">,</span> <span class="ss">loads: </span><span class="no">Types</span><span class="o">::</span><span class="no">RoomType</span>

  <span class="c1"># It's passed to other methods as `room`</span>
  <span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This can be invoked as</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="p">(</span><span class="nv">$roomId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">messageWasPosted</span><span class="p">(</span><span class="n">roomId</span><span class="p">:</span><span class="w"> </span><span class="nv">$roomId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="c"># ...</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>If the ID doesn’t find an object, then the subscription will be unsubscribed (with <code class="language-plaintext highlighter-rouge">#unsubscribe</code>, see below).</p>

<h2 id="fields">Fields</h2>

<p>Like mutations, you can use a generated return type for subscriptions. When you add <code class="language-plaintext highlighter-rouge">field(...)</code>s to a subscription, they’ll be added to the subscription’s generated return type. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::MessageWasPosted</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
  <span class="n">field</span> <span class="ss">:room</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">RoomType</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
  <span class="n">field</span> <span class="ss">:message</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">MessageType</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>will generate:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="w"> </span><span class="n">MessageWasPostedPayload</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">room</span><span class="p">:</span><span class="w"> </span><span class="n">Room</span><span class="p">!</span><span class="w">
  </span><span class="n">message</span><span class="p">:</span><span class="w"> </span><span class="n">Message</span><span class="p">!</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Which you can use in queries like:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="p">(</span><span class="nv">$roomId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">messageWasPosted</span><span class="p">(</span><span class="n">roomId</span><span class="p">:</span><span class="w"> </span><span class="nv">$roomId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">room</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">name</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="n">message</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">author</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="n">handle</span><span class="w">
      </span><span class="p">}</span><span class="w">
      </span><span class="n">body</span><span class="w">
      </span><span class="n">postedAt</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>If you remove <code class="language-plaintext highlighter-rouge">null: false</code>, then you can return different data in the initial subscription and the subsequent updates. (See lifecycle methods below.)</p>

<p>Instead of a generated type, you can provide an already-configured type with <code class="language-plaintext highlighter-rouge">payload_type</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Just return a message</span>
<span class="n">payload_type</span> <span class="no">Types</span><span class="o">::</span><span class="no">MessageType</span>
</code></pre></div></div>

<p>(In that case, don’t return a hash from <code class="language-plaintext highlighter-rouge">#subscribe</code> or <code class="language-plaintext highlighter-rouge">#update</code>, return a <code class="language-plaintext highlighter-rouge">message</code> object instead.)</p>

<h2 id="scope">Scope</h2>

<p>Usually, GraphQL-Ruby uses explicitly-passed arguments to determine when a <a href="/subscriptions/triggers">trigger</a> applies to an active subscription. But, you can use <code class="language-plaintext highlighter-rouge">subscription_scope</code> to configure <em>implicit</em> conditions on updates. When <code class="language-plaintext highlighter-rouge">subscription_scope</code> is configured, only triggers with a matching <code class="language-plaintext highlighter-rouge">scope:</code> value will cause clients to receive updates.</p>

<p><code class="language-plaintext highlighter-rouge">subscription_scope</code> accepts a symbol and the given symbol will be looked up in <code class="language-plaintext highlighter-rouge">context</code> to find a scope value.</p>

<p>For example, this subscription will use <code class="language-plaintext highlighter-rouge">context[:current_organization_id]</code> as a scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::EmployeeHired</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
  <span class="c1"># ...</span>
  <span class="n">subscription_scope</span> <span class="ss">:current_organization_id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Clients subscribe <em>without</em> any arguments:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">employeeHired</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">hireDate</span><span class="w">
    </span><span class="n">employee</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">name</span><span class="w">
      </span><span class="n">department</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>But <code class="language-plaintext highlighter-rouge">.trigger</code>s are routed using <code class="language-plaintext highlighter-rouge">scope:</code>. So, if the subscriber’s context includes <code class="language-plaintext highlighter-rouge">current_organization_id: 100</code>, then the trigger must include the same <code class="language-plaintext highlighter-rouge">scope:</code> value:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyAppSchema</span><span class="p">.</span><span class="nf">subscriptions</span><span class="p">.</span><span class="nf">trigger</span><span class="p">(</span>
  <span class="c1"># Field name</span>
  <span class="ss">:employee_hired</span><span class="p">,</span>
  <span class="c1"># Arguments</span>
  <span class="p">{},</span>
  <span class="c1"># Object</span>
  <span class="p">{</span> <span class="ss">hire_date: </span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">,</span> <span class="ss">employee: </span><span class="n">new_employee</span> <span class="p">},</span>
  <span class="c1"># This corresponds to `context[:current_organization_id]`</span>
  <span class="c1"># in the original subscription:</span>
  <span class="ss">scope: </span><span class="mi">100</span>
 <span class="p">)</span>
</code></pre></div></div>

<p>Scope is also used for determining whether subscribers can receive the same <a href="/subscriptions/implementation#broadcast">broadcast</a>.</p>

<h2 id="check-permissions-with-authorized">Check Permissions with #authorized?</h2>

<p>Suppose a client is subscribing to messages in a chat room:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="p">(</span><span class="nv">$roomId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">messageWasPosted</span><span class="p">(</span><span class="n">roomId</span><span class="p">:</span><span class="w"> </span><span class="nv">$roomId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">message</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">author</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="p">}</span><span class="w">
      </span><span class="n">body</span><span class="w">
      </span><span class="n">postedAt</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>You can implement <code class="language-plaintext highlighter-rouge">#authorized?</code> to check that the user has permission to subscribe to these arguments (and receive updates for these arguments), for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">authorized?</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
  <span class="k">super</span> <span class="o">&amp;&amp;</span> <span class="n">context</span><span class="p">[</span><span class="ss">:viewer</span><span class="p">].</span><span class="nf">can_read_messages?</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The method may return <code class="language-plaintext highlighter-rouge">false</code> or raise a <code class="language-plaintext highlighter-rouge">GraphQL::ExecutionError</code> to halt execution.</p>

<p>This method is called <em>before</em> <code class="language-plaintext highlighter-rouge">#subscribe</code> and <code class="language-plaintext highlighter-rouge">#update</code>, described below. This way, if a user’s permissions have changed since they subscribed, they won’t receive updates unauthorized updates.</p>

<p>Also, if this method fails before calling <code class="language-plaintext highlighter-rouge">#update</code>, then the client will be automatically unsubscribed (with <code class="language-plaintext highlighter-rouge">#unsubscribe</code>).</p>

<h2 id="initial-subscription-with-subscribe">Initial Subscription with #subscribe</h2>

<p><code class="language-plaintext highlighter-rouge">def subscribe(**args)</code> is called when a client <em>first</em> sends a <code class="language-plaintext highlighter-rouge">subscription { ... }</code> request. In this method, you can do a few things:</p>

<ul>
  <li>Raise <code class="language-plaintext highlighter-rouge">GraphQL::ExecutionError</code> to halt and return an error</li>
  <li>Return a value to give the client an initial response</li>
  <li>Return <code class="language-plaintext highlighter-rouge">:no_response</code> to skip the initial response</li>
  <li>Return <code class="language-plaintext highlighter-rouge">super</code> to fall back to the default behavior (which is <code class="language-plaintext highlighter-rouge">:no_response</code>).</li>
</ul>

<p>You can define this method to add initial responses or perform other logic before subscribing.</p>

<h3 id="adding-an-initial-response">Adding an Initial Response</h3>

<p>By default, GraphQL-Ruby returns <em>nothing</em> (<code class="language-plaintext highlighter-rouge">:no_response</code>) on an initial subscription. But, you may choose to override this and return a value in <code class="language-plaintext highlighter-rouge">def subscribe</code>. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::MessageWasPosted</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
  <span class="c1"># ...</span>
  <span class="n">field</span> <span class="ss">:room</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">RoomType</span>

  <span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
    <span class="c1"># authorize, etc ...</span>
    <span class="c1"># Return the room in the initial response</span>
    <span class="p">{</span>
      <span class="ss">room: </span><span class="n">room</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, a client can get some initial data with:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">subscription</span><span class="p">(</span><span class="nv">$roomId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!)</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">messageWasPosted</span><span class="p">(</span><span class="n">roomId</span><span class="p">:</span><span class="w"> </span><span class="nv">$roomId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">room</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="n">name</span><span class="w">
      </span><span class="n">messages</span><span class="p">(</span><span class="n">last</span><span class="p">:</span><span class="w"> </span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="c"># ...</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="subsequent-updates-with-update">Subsequent Updates with #update</h2>

<p>After a client has registered a subscription, the application may trigger subscription updates with <code class="language-plaintext highlighter-rouge">MySchema.subscriptions.trigger(...)</code> (see the <a href="/subscriptions/triggers">Triggers guide</a> for more). Then, <code class="language-plaintext highlighter-rouge">def update</code> will be called for each client’s subscription. In this method you can:</p>

<ul>
  <li>Unsubscribe the client with <code class="language-plaintext highlighter-rouge">unsubscribe</code></li>
  <li>Return a value with <code class="language-plaintext highlighter-rouge">super</code> (which returns <code class="language-plaintext highlighter-rouge">object</code>) or by returning a different value.</li>
  <li>Return <code class="language-plaintext highlighter-rouge">NO_UPDATE</code> to skip this update</li>
</ul>

<h3 id="skipping-subscription-updates">Skipping subscription updates</h3>

<p>Perhaps you don’t want to send updates to a certain subscriber. For example, if someone leaves a comment, you might want to push the new comment to <em>other</em> subscribers, but not the commenter, who already has that comment data. You can accomplish this by returning <code class="language-plaintext highlighter-rouge">NO_UPDATE</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::CommentWasAdded</span> <span class="o">&lt;</span> <span class="no">Subscriptions</span><span class="o">::</span><span class="no">BaseSubscription</span>
  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">post_id</span><span class="p">:)</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">object</span> <span class="c1"># #&lt;Comment ...&gt;</span>
    <span class="k">if</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author</span> <span class="o">==</span> <span class="n">context</span><span class="p">[</span><span class="ss">:viewer</span><span class="p">]</span>
      <span class="no">NO_UPDATE</span>
    <span class="k">else</span>
      <span class="c1"># Continue updating this client, since it's not the commenter</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="returning-a-different-object-for-subscription-updates">Returning a different object for subscription updates</h3>

<p>By default, whatever object you pass to <code class="language-plaintext highlighter-rouge">.trigger(event_name, args, object)</code> will be used for responding to subscription fields. But, you can return a different object from <code class="language-plaintext highlighter-rouge">#update</code> to override this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">field</span> <span class="ss">:queue</span><span class="p">,</span> <span class="no">Types</span><span class="o">::</span><span class="no">QueueType</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>

<span class="c1"># eg, `MySchema.subscriptions.trigger("queueWasUpdated", {name: "low-priority"}, :low_priority)`</span>
<span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="nb">name</span><span class="p">:)</span>
  <span class="c1"># Make a Queue object which _represents_ the queue with this name</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="no">JobQueue</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>

  <span class="c1"># This object was passed to `.trigger`, but we're ignoring it:</span>
  <span class="n">object</span> <span class="c1"># =&gt; :low_priority</span>

  <span class="c1"># return the queue instead:</span>
  <span class="p">{</span> <span class="ss">queue: </span><span class="n">queue</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="terminating-the-subscription-with-unsubscribe">Terminating the subscription with #unsubscribe</h2>

<p>Within a subscription method, you may call <code class="language-plaintext highlighter-rouge">unsubscribe</code> to terminate the client’s subscription, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
  <span class="k">if</span> <span class="n">room</span><span class="p">.</span><span class="nf">archived?</span>
    <span class="c1"># Don't let anyone subscribe to messages on an archived room</span>
    <span class="n">unsubscribe</span>
  <span class="k">else</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">#unsubscribe</code> has the following effects:</p>

<ul>
  <li>The subscription is unregistered from the backend (this is backend-specific)</li>
  <li>The client is told to unsubscribe (this is transport-specific)</li>
</ul>

<p>Arguments with <code class="language-plaintext highlighter-rouge">loads:</code> configurations will call <code class="language-plaintext highlighter-rouge">unsubscribe</code> if they are <code class="language-plaintext highlighter-rouge">required: true</code> (which is the default) and their ID doesn’t return a value. (It’s assumed that the subscribed object was deleted.)</p>

<p>You can provide a final update value with <code class="language-plaintext highlighter-rouge">unsubscribe</code> by passing a value to the method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">room</span><span class="p">:)</span>
  <span class="k">if</span> <span class="n">room</span><span class="p">.</span><span class="nf">archived?</span>
    <span class="c1"># Don't let anyone subscribe to messages on an archived room</span>
    <span class="n">unsubscribe</span><span class="p">({</span><span class="ss">message: </span><span class="s2">"This room has been archived"</span><span class="p">})</span>
  <span class="k">else</span>
    <span class="k">super</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="extras">Extras</h2>

<p>Subscription methods can access query-related metadata by configuring <code class="language-plaintext highlighter-rouge">extras [...]</code> in the class definition. For example, to use a <code class="language-plaintext highlighter-rouge">lookahead</code> and the <code class="language-plaintext highlighter-rouge">ast_node</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Subscriptions::JobFinished</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">Subscription</span>
  <span class="c1"># ...</span>
  <span class="n">extras</span> <span class="p">[</span><span class="ss">:lookahead</span><span class="p">,</span> <span class="ss">:ast_node</span><span class="p">]</span>

  <span class="k">def</span> <span class="nf">subscribe</span><span class="p">(</span><span class="n">lookahead</span><span class="p">:,</span> <span class="n">ast_node</span><span class="p">:)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">lookahead</span><span class="p">:,</span> <span class="n">ast_node</span><span class="p">:)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>See the <a href="/fields/introduction#extra-field-metadata">Extra Field Metadata</a> for more information about available metadata.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/subscriptions/subscription_classes.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Subscription Classes">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
  function navigateToSelected(selectElement) {
    var nextPage = selectElement.selectedOptions[0].dataset["target"]
    document.location = nextPage
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
    <script>
      detectDarkTheme(false) // do it again to update the images
    </script>
  </body>
</html>
