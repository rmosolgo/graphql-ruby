<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>GraphQL Ruby</title>
    <link rel="stylesheet" href="/stylesheet.css">
    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.2.3">
  </head>
  <body class="hack">
    <div class="container">
      <div style="display: flex; justify-content: center;">
<strong style="white-space: pre; line-height: 1.1em; display: inline-block;">
    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„     â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–„â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„    â–„â–ˆ    â–ˆâ–„    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„    â–„â–ˆ
   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆâ–ˆ    â–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ
  â–„â–ˆâ–ˆâ–ˆ         â–„â–ˆâ–ˆâ–ˆâ–„â–„â–„â–„â–ˆâ–ˆâ–€   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–„â–ˆâ–ˆâ–ˆâ–„â–„â–„â–„â–ˆâ–ˆâ–ˆâ–„â–„ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ
 â–€â–€â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–„  â–€â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–€   â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€  â–€â–€â–ˆâ–ˆâ–ˆâ–€â–€â–€â–€â–ˆâ–ˆâ–ˆâ–€  â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ          â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ
   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ          â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ  â–€ â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–Œ    â–„
   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€    â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–€   â–„â–ˆâ–ˆâ–ˆâ–ˆâ–€        â–ˆâ–ˆâ–ˆ    â–ˆâ–€     â–€â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–€â–„â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–„â–„â–ˆâ–ˆ
                â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ                                                      â–€
</strong>
      </div>
      <p style="text-align: center;">A GraphQL server implementation for Ruby</p>

      <div class="grid -between">
        <div class="cell -3of12">
          <h3><a href="/">Readme</a></h3>
          <h3>Guides</h3>
          <ul>
            <li><a href="/guides/introduction/">Introduction</a></li>
            <li><a href="/guides/defining_your_schema/">Defining a Schema</a></li>
            <li><a href="/guides/executing_queries/">Executing Queries</a></li>
            <li><a href="/guides/code_reuse/">Code Reuse</a></li>
            <li><a href="/guides/security/">Security</a></li>
            <li><a href="/guides/testing/">Testing</a></li>
          </ul>
          <h3><a href="http://www.rubydoc.info/github/rmosolgo/graphql-ruby">API Docs</a></h3>
          <h3><a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a></h3>
        </div>
        <div class="cell -9of12">
          <h1>GraphQL Security</h1>

<p>Since a GraphQL endpoint provides arbitrary access to your application, you should employ safeguards to prevent large queries from swamping your system.</p>

<h2>Limiting lists of items</h2>

<p>Always limit the number of items which can be returned from a list field. For example, use a <code>limit:</code> argument and make sure it&#39;s not too big:</p>
<pre class="highlight ruby"><code><span class="n">field</span> <span class="ss">:items</span><span class="p">,</span> <span class="n">types</span><span class="p">[</span><span class="no">ItemType</span><span class="p">]</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:limit</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Int</span><span class="p">,</span> <span class="ss">default_value: </span><span class="mi">20</span>
  <span class="n">resolve</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># Cap the number of items at 30</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="ss">:limit</span><span class="p">],</span> <span class="mi">30</span><span class="p">].</span><span class="nf">max</span>
    <span class="n">obj</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>This way, you won&#39;t hit your database for 1000 items!</p>

<h2>Enforce a timeout</h2>

<p>You can apply a timeout to query execution with <code>TimeoutMiddleware</code>. For example:</p>
<pre class="highlight ruby"><code><span class="no">MySchema</span><span class="p">.</span><span class="nf">middleware</span> <span class="o">&lt;&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">TimeoutMiddleware</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">max_seconds: </span><span class="mi">2</span><span class="p">)</span>
</code></pre>
<p>After <code>max_seconds</code>, no new fields will be resolved. Instead, errors will be added to the <code>errors</code> key for fields that weren&#39;t resolved.</p>

<p><strong>Note</strong> that this does not <em>interrupt</em> field execution. If you&#39;re making external calls (eg, HTTP requests or database queries), make sure to use a &quot;lower level&quot; timeout for the specific operation.</p>

<p>To log the error, pass a block to the middleware:</p>
<pre class="highlight ruby"><code><span class="no">MySchema</span><span class="p">.</span><span class="nf">middleware</span> <span class="o">&lt;&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="o">::</span><span class="no">TimeoutMiddleware</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">max_seconds: </span><span class="mi">2</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">err</span><span class="p">,</span> <span class="n">query</span><span class="o">|</span>
  <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"GraphQL Timeout: </span><span class="si">#{</span><span class="n">query</span><span class="p">.</span><span class="nf">query_string</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<h2>Prevent complex queries</h2>

<p>Fields have a &quot;complexity&quot; value which can be configured in their definition. It can be a constant (numeric) value, or a proc. It can be defined as a keyword <em>or</em> inside the configuration block. For example:</p>
<pre class="highlight ruby"><code><span class="c1"># Constant complexity:</span>
<span class="n">field</span> <span class="ss">:top_score</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Int</span><span class="p">,</span> <span class="ss">complexity: </span><span class="mi">10</span>

<span class="c1"># Dynamic complexity:</span>
<span class="n">field</span> <span class="ss">:top_scorers</span><span class="p">,</span> <span class="n">types</span><span class="p">[</span><span class="no">PlayerType</span><span class="p">]</span> <span class="k">do</span>
  <span class="n">argument</span> <span class="ss">:limit</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Int</span><span class="p">,</span> <span class="ss">default_value: </span><span class="mi">5</span>
  <span class="n">complexity</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">child_complexity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">ctx</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">].</span><span class="nf">staff?</span>
      <span class="c1"># no limit for staff users</span>
      <span class="mi">0</span>
    <span class="k">else</span>
      <span class="c1"># `child_complexity` is the value for selections</span>
      <span class="c1"># which were made on the items of this list.</span>
      <span class="c1">#</span>
      <span class="c1"># We don't know how many items will be fetched because</span>
      <span class="c1"># we haven't run the query yet, but we can estimate by</span>
      <span class="c1"># using the `limit` argument which we defined above.</span>
      <span class="n">args</span><span class="p">[</span><span class="ss">:limit</span><span class="p">]</span> <span class="o">*</span> <span class="n">child_complexity</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>Then, define your <code>max_complexity</code> at the schema-level:</p>
<pre class="highlight ruby"><code><span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
 <span class="c1"># ...</span>
 <span class="ss">max_complexity: </span><span class="mi">100</span>
<span class="p">)</span>
</code></pre>
<p>Or, at the query-level, which overrides the schema-level setting:</p>
<pre class="highlight ruby"><code><span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="ss">max_complexity: </span><span class="mi">100</span><span class="p">)</span>
</code></pre>
<p>Using <code>nil</code> will disable the validation:</p>
<pre class="highlight ruby"><code><span class="c1"># ðŸ˜§ Anything goes!</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="ss">max_complexity: </span><span class="kp">nil</span><span class="p">)</span>
</code></pre>
<p>To get a feeling for complexity of queries in your system, you can use the <code>QueryComplexity</code> query reducer. Hook it up to log out values from each query:</p>
<pre class="highlight ruby"><code><span class="n">log_query_complexity</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">QueryComplexity</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">query</span><span class="p">,</span> <span class="n">complexity</span><span class="o">|</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"[GraphQL Query Complexity] </span><span class="si">#{</span><span class="n">complexity</span><span class="si">}</span><span class="s2">  | staff? </span><span class="si">#{</span><span class="n">query</span><span class="p">.</span><span class="nf">context</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">].</span><span class="nf">staff?</span><span class="si">}</span><span class="s2">"</span><span class="p">)}</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">query_analyzers</span> <span class="o">&lt;&lt;</span> <span class="n">log_query_complexity</span>
</code></pre>
<h2>Prevent deeply-nested queries</h2>

<p>You can also reject queries based on the depth of their nesting. You can define <code>max_depth</code> at schema-level or query-level:</p>
<pre class="highlight ruby"><code><span class="c1"># Schema-level:</span>
<span class="no">MySchema</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="c1"># ...</span>
  <span class="ss">max_depth: </span><span class="mi">10</span>
<span class="p">)</span>

<span class="c1"># Query-level, which overrides the schema-level setting:</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="ss">max_depth: </span><span class="mi">10</span><span class="p">)</span>
</code></pre>
<p>You can use <code>nil</code> to disable the validation:</p>
<pre class="highlight ruby"><code><span class="c1"># This query won't be validated:</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_string</span><span class="p">,</span> <span class="ss">max_depth: </span><span class="kp">nil</span><span class="p">)</span>
</code></pre>
<p>To get a feeling for depth of queries in your system, you can use the <code>QueryDepth</code> query reducer. Hook it up to log out values from each query:</p>
<pre class="highlight ruby"><code><span class="n">log_query_depth</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">QueryDepth</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">query</span><span class="p">,</span> <span class="n">depth</span><span class="o">|</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"[GraphQL Query Depth] </span><span class="si">#{</span><span class="n">depth</span><span class="si">}</span><span class="s2"> || staff?  </span><span class="si">#{</span><span class="n">query</span><span class="p">.</span><span class="nf">context</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">].</span><span class="nf">staff?</span><span class="si">}</span><span class="s2">"</span><span class="p">)}</span>
<span class="no">MySchema</span><span class="p">.</span><span class="nf">query_analyzers</span> <span class="o">&lt;&lt;</span> <span class="n">log_query_depth</span>
</code></pre>
<h2>Only execute predefined queries</h2>

<p>If you don&#39;t want to accept arbitrary queries from the &quot;outside world&quot;, you can cache queries on the server and fetch them in response to specific requests.</p>

<p>For example, you could store parsed <code>GraphQL::Language::Nodes::Document</code> objects in a cache:</p>
<pre class="highlight ruby"><code><span class="n">parsed_document</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">query_string</span><span class="p">)</span>
<span class="n">operation_name</span> <span class="o">=</span> <span class="n">parsed_document</span><span class="p">.</span><span class="nf">definitions</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">name</span>
<span class="no">MyCache</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">operation_name</span><span class="p">,</span> <span class="n">parsed_document</span><span class="p">)</span>
</code></pre>
<p>Then, later, you could fetch the document from storage and use it to run a query:</p>
<pre class="highlight ruby"><code><span class="c1"># later ...</span>
<span class="n">operation_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:operation_name</span><span class="p">]</span>
<span class="n">document</span> <span class="o">=</span> <span class="no">MyCache</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">operation_name</span><span class="p">)</span>
<span class="k">if</span> <span class="n">document</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="k">raise</span><span class="p">(</span><span class="s2">"No stored operation called </span><span class="si">#{</span><span class="n">operation_name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="k">else</span>
  <span class="c1"># use `document` instead of a query string:</span>
  <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">document</span><span class="p">,</span> <span class="ss">context: </span><span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">})</span>
<span class="k">end</span>
</code></pre>
<p>This way, no unknown queries are evaluated by the server.</p>

        </div>
      </div>
    </div>
  </body>
</html>
