# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/httpclient/all/httpclient.rbi
#
# httpclient-2.8.3
class HTTPClient
  def adapt_block(&block); end
  def agent_name; end
  def agent_name=(rhs); end
  def base_url; end
  def base_url=(arg0); end
  def connect_timeout; end
  def connect_timeout=(rhs); end
  def cookie_manager; end
  def cookie_manager=(arg0); end
  def cookies; end
  def create_boundary; end
  def create_request(method, uri, query, body, header); end
  def debug_dev; end
  def debug_dev=(dev); end
  def default_header; end
  def default_header=(arg0); end
  def default_redirect_uri_callback(uri, res); end
  def delete(uri, *args, &block); end
  def delete_async(uri, *args); end
  def do_get_block(req, proxy, conn, &block); end
  def do_get_header(req, res, sess); end
  def do_get_stream(req, proxy, conn); end
  def do_request(method, uri, query, body, header, &block); end
  def do_request_async(method, uri, query, body, header); end
  def dump_dummy_request_response(req, res); end
  def file_in_form_data?(body); end
  def follow_redirect(method, uri, query, body, header, &block); end
  def follow_redirect_count; end
  def follow_redirect_count=(arg0); end
  def force_basic_auth=(force_basic_auth); end
  def from; end
  def from=(rhs); end
  def get(uri, *args, &block); end
  def get_async(uri, *args); end
  def get_content(uri, *args, &block); end
  def getenv(name); end
  def hashy_argument_has_keys(args, *key); end
  def head(uri, *args); end
  def head_async(uri, *args); end
  def initialize(*args, &block); end
  def keep_alive_timeout; end
  def keep_alive_timeout=(rhs); end
  def keep_webmock_compat; end
  def load_environment; end
  def no_proxy; end
  def no_proxy=(no_proxy); end
  def no_proxy?(uri); end
  def options(uri, *args, &block); end
  def options_async(uri, *args); end
  def override_header(header, key, value); end
  def patch(uri, *args, &block); end
  def patch_async(uri, *args); end
  def post(uri, *args, &block); end
  def post_async(uri, *args); end
  def post_content(uri, *args, &block); end
  def propfind(uri, *args, &block); end
  def propfind_async(uri, *args); end
  def proppatch(uri, *args, &block); end
  def proppatch_async(uri, *args); end
  def protect_keep_alive_disconnected; end
  def protocol_retry_count; end
  def protocol_retry_count=(rhs); end
  def protocol_version; end
  def protocol_version=(rhs); end
  def proxy; end
  def proxy=(proxy); end
  def proxy_auth; end
  def put(uri, *args, &block); end
  def put_async(uri, *args); end
  def read_block_size; end
  def read_block_size=(rhs); end
  def receive_timeout; end
  def receive_timeout=(rhs); end
  def redirect_uri_callback=(redirect_uri_callback); end
  def request(method, uri, *args, &block); end
  def request_async(method, uri, query = nil, body = nil, header = nil); end
  def request_async2(method, uri, *args); end
  def request_filter; end
  def reset(uri); end
  def reset_all; end
  def save_cookie_store; end
  def self.attr_proxy(symbol, assignable = nil); end
  def self.delete(*arg, &block); end
  def self.get(*arg, &block); end
  def self.get_content(*arg, &block); end
  def self.head(*arg, &block); end
  def self.options(*arg, &block); end
  def self.post(*arg, &block); end
  def self.post_content(*arg, &block); end
  def self.propfind(*arg, &block); end
  def self.proppatch(*arg, &block); end
  def self.put(*arg, &block); end
  def self.trace(*arg, &block); end
  def send_timeout; end
  def send_timeout=(rhs); end
  def set_auth(domain, user, passwd); end
  def set_basic_auth(domain, user, passwd); end
  def set_cookie_store(filename); end
  def set_encoding(str, encoding); end
  def set_proxy_auth(user, passwd); end
  def socket_local; end
  def socket_local=(rhs); end
  def socket_sync; end
  def socket_sync=(rhs); end
  def ssl_config; end
  def strict_redirect_uri_callback(uri, res); end
  def strict_response_size_check; end
  def strict_response_size_check=(rhs); end
  def success_content(res); end
  def tcp_keepalive; end
  def tcp_keepalive=(rhs); end
  def test_loopback_http_response; end
  def test_loopback_response; end
  def to_resource_url(uri); end
  def trace(uri, *args, &block); end
  def trace_async(uri, *args); end
  def transparent_gzip_decompression; end
  def transparent_gzip_decompression=(rhs); end
  def www_auth; end
  include HTTPClient::Util
end
module HTTPClient::Util
  def argument_to_hash(args, *field); end
  def hash_find_value(hash, &block); end
  def http?(uri); end
  def https?(uri); end
  def keyword_argument(args, *field); end
  def self.hash_find_value(hash, &block); end
  def self.try_require(feature); end
  def self.uri_dirname(uri); end
  def self.uri_part_of(uri, part); end
  def self.urify(uri); end
  def try_require(feature); end
  def uri_dirname(uri); end
  def uri_part_of(uri, part); end
  def urify(uri); end
  def warning(message); end
end
class HTTPClient::Util::AddressableURI < Addressable::URI
  def authority; end
  def hostname; end
  def port; end
end
class HTTPClient::SSLConfig
  def add_crl(crl); end
  def add_trust_ca(trust_ca_file_or_hashed_dir); end
  def add_trust_ca_to_store(cert_store, trust_ca_file_or_hashed_dir); end
  def cert_store; end
  def cert_store=(cert_store); end
  def cert_store_crl_items; end
  def cert_store_items; end
  def change_notify; end
  def ciphers; end
  def ciphers=(rhs); end
  def clear_cert_store; end
  def client_ca; end
  def client_ca=(rhs); end
  def client_cert; end
  def client_cert=(rhs); end
  def client_key; end
  def client_key=(rhs); end
  def client_key_pass; end
  def client_key_pass=(rhs); end
  def default_verify_callback(is_ok, ctx); end
  def initialize(client); end
  def load_cacerts(cert_store); end
  def load_trust_ca; end
  def options; end
  def options=(rhs); end
  def post_connection_check(peer_cert, hostname); end
  def sample_verify_callback(is_ok, ctx); end
  def self.attr_config(symbol); end
  def set_client_cert_file(cert_file, key_file, pass = nil); end
  def set_context(ctx); end
  def set_crl(crl); end
  def set_default_paths; end
  def set_trust_ca(trust_ca_file_or_hashed_dir); end
  def ssl_version; end
  def ssl_version=(rhs); end
  def timeout; end
  def timeout=(rhs); end
  def verify?; end
  def verify_callback; end
  def verify_callback=(rhs); end
  def verify_depth; end
  def verify_depth=(rhs); end
  def verify_mode; end
  def verify_mode=(rhs); end
  include HTTPClient::Util
  include OpenSSL
end
module OpenSSL
end
module OpenSSL::X509
end
class OpenSSL::X509::Store
  def _httpclient_cert_store_items; end
end
class HTTPClient::Connection
  def async_thread; end
  def async_thread=(arg0); end
  def finished?; end
  def initialize(header_queue = nil, body_queue = nil); end
  def join; end
  def pop; end
  def push(result); end
end
module HTTPClient::Timeout
end
module HTTP
end
module HTTP::Status
  def self.redirect?(status); end
  def self.successful?(status); end
end
class HTTP::Message
  def body; end
  def body=(body); end
  def body_encoding; end
  def code; end
  def content; end
  def content_type; end
  def content_type=(content_type); end
  def contenttype; end
  def contenttype=(content_type); end
  def cookies; end
  def dump(dev = nil); end
  def header; end
  def headers; end
  def http_body; end
  def http_body=(body); end
  def http_header; end
  def http_header=(arg0); end
  def http_version; end
  def http_version=(http_version); end
  def initialize; end
  def ok?; end
  def peer_cert; end
  def peer_cert=(arg0); end
  def previous; end
  def previous=(arg0); end
  def reason; end
  def reason=(reason); end
  def redirect?; end
  def see_other?; end
  def self.create_query_part_str(query); end
  def self.escape(str); end
  def self.escape_query(query); end
  def self.file?(obj); end
  def self.get_mime_type_func; end
  def self.internal_mime_type(path); end
  def self.keep_alive_enabled?(version); end
  def self.mime_type(path); end
  def self.mime_type_handler; end
  def self.mime_type_handler=(handler); end
  def self.multiparam_query?(query); end
  def self.new(*arg0); end
  def self.new_connect_request(uri); end
  def self.new_request(method, uri, query = nil, body = nil, boundary = nil); end
  def self.new_response(body, req = nil); end
  def self.parse(query); end
  def self.set_mime_type_func(handler); end
  def self.unescape(string); end
  def status; end
  def status=(status); end
  def status_code; end
  def version; end
  def version=(version); end
  include HTTPClient::Util
end
class HTTP::Message::Headers
  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def all; end
  def body_charset; end
  def body_charset=(arg0); end
  def body_date; end
  def body_date=(arg0); end
  def body_encoding; end
  def body_size; end
  def body_size=(body_size); end
  def body_type; end
  def body_type=(arg0); end
  def charset_label; end
  def chunked; end
  def chunked=(arg0); end
  def content_type; end
  def content_type=(content_type); end
  def contenttype; end
  def contenttype=(content_type); end
  def create_query_part; end
  def create_query_uri; end
  def delete(key); end
  def dump; end
  def get(key = nil); end
  def http_version; end
  def http_version=(arg0); end
  def init_connect_request(uri); end
  def init_request(method, uri, query = nil); end
  def init_response(status_code, req = nil); end
  def initialize; end
  def reason_phrase; end
  def reason_phrase=(arg0); end
  def request_absolute_uri; end
  def request_absolute_uri=(arg0); end
  def request_line; end
  def request_method; end
  def request_query; end
  def request_query=(arg0); end
  def request_uri; end
  def request_uri=(arg0); end
  def response_status_line; end
  def set(key, value); end
  def set_body_encoding; end
  def set_date_header; end
  def set_header; end
  def set_headers(headers); end
  def set_request_header; end
  def set_response_header; end
  def status_code; end
  def status_code=(status_code); end
end
class HTTP::Message::Body
  def build_query_multipart_str(query, boundary); end
  def chunk_size; end
  def chunk_size=(arg0); end
  def content; end
  def dump(header = nil, dev = nil); end
  def dump_chunk(str); end
  def dump_chunk_size(size); end
  def dump_chunked(header = nil, dev = nil); end
  def dump_chunks(io, dev); end
  def dump_file(io, dev, sz); end
  def dump_last_chunk; end
  def init_request(body = nil, boundary = nil); end
  def init_response(body = nil); end
  def initialize; end
  def params_from_file(value); end
  def positions; end
  def positions=(arg0); end
  def remember_pos(io); end
  def reset_pos(io); end
  def set_content(body, boundary = nil); end
  def size; end
end
class HTTP::Message::Body::Parts
  def add(part); end
  def add_size(part, sz); end
  def initialize; end
  def parts; end
  def size; end
  def sizes; end
end
class HTTPClient::SSLSocket
  def <<(str); end
  def check_mask(value, mask); end
  def close; end
  def closed?; end
  def create_openssl_socket(socket); end
  def debug(str); end
  def eof?; end
  def flush; end
  def gets(rs); end
  def initialize(socket, dest, config, opts = nil); end
  def peer_cert; end
  def post_connection_check(hostname); end
  def read(size, buf = nil); end
  def readpartial(size, buf = nil); end
  def self.create_socket(session); end
  def ssl_connect(hostname = nil); end
  def sync; end
  def sync=(sync); end
end
class HTTPClient::Site
  def ==(rhs); end
  def addr; end
  def eql?(rhs); end
  def hash; end
  def host; end
  def host=(arg0); end
  def hostname; end
  def initialize(uri = nil); end
  def inspect; end
  def match(uri); end
  def port; end
  def port=(arg0); end
  def scheme; end
  def scheme=(arg0); end
  def to_s; end
end
class HTTPClient::SessionManager
  def add_cached_session(sess); end
  def agent_name; end
  def agent_name=(arg0); end
  def chunk_size; end
  def chunk_size=(arg0); end
  def close(dest); end
  def close_all; end
  def connect_retry; end
  def connect_retry=(arg0); end
  def connect_timeout; end
  def connect_timeout=(arg0); end
  def debug_dev; end
  def debug_dev=(arg0); end
  def from; end
  def from=(arg0); end
  def get_cached_session(site); end
  def get_session(req, via_proxy = nil); end
  def initialize(client); end
  def keep(sess); end
  def keep_alive_timeout; end
  def keep_alive_timeout=(arg0); end
  def open(uri, via_proxy = nil); end
  def protocol_retry_count; end
  def protocol_retry_count=(arg0); end
  def protocol_version; end
  def protocol_version=(arg0); end
  def proxy=(proxy); end
  def query(req, via_proxy); end
  def read_block_size; end
  def read_block_size=(arg0); end
  def receive_timeout; end
  def receive_timeout=(arg0); end
  def reset(uri); end
  def reset_all; end
  def scrub_cached_session(now); end
  def send_timeout; end
  def send_timeout=(arg0); end
  def socket_local; end
  def socket_local=(arg0); end
  def socket_sync; end
  def socket_sync=(arg0); end
  def ssl_config; end
  def ssl_config=(arg0); end
  def strict_response_size_check; end
  def strict_response_size_check=(arg0); end
  def tcp_keepalive; end
  def tcp_keepalive=(arg0); end
  def test_loopback_http_response; end
  def transparent_gzip_decompression; end
  def transparent_gzip_decompression=(arg0); end
  def valid_session?(sess, now); end
end
module HTTPClient::SocketWrap
  def <<(str); end
  def close; end
  def closed?; end
  def eof?; end
  def flush; end
  def gets(rs); end
  def initialize(socket, *args); end
  def read(size, buf = nil); end
  def readpartial(size, buf = nil); end
  def sync; end
  def sync=(sync); end
end
module HTTPClient::DebugSocket
  def <<(str); end
  def close; end
  def debug(str); end
  def debug_dev=(debug_dev); end
  def gets(rs); end
  def read(size, buf = nil); end
  def readpartial(size, buf = nil); end
  extend HTTPClient::SocketWrap
end
class HTTPClient::LoopBackSocket
  def <<(str); end
  def initialize(host, port, response); end
  def peer_cert; end
  include HTTPClient::SocketWrap
end
class HTTPClient::Session
  def close; end
  def closed?; end
  def connect; end
  def connect_retry; end
  def connect_retry=(arg0); end
  def connect_ssl_proxy(socket, uri); end
  def connect_timeout; end
  def connect_timeout=(arg0); end
  def content_inflater_block(content_encoding, block); end
  def create_loopback_socket(host, port, str); end
  def create_socket(host, port); end
  def debug_dev; end
  def debug_dev=(arg0); end
  def dest; end
  def empty_bin_str; end
  def eof?; end
  def get_body(&block); end
  def get_header; end
  def initialize(client, dest, agent_name, from); end
  def last_used; end
  def no_message_body?(status); end
  def parse_content_header(key, value); end
  def parse_header(socket); end
  def protocol_retry_count; end
  def protocol_retry_count=(arg0); end
  def proxy; end
  def proxy=(arg0); end
  def query(req); end
  def read_block_size; end
  def read_block_size=(arg0); end
  def read_body_chunked(&block); end
  def read_body_length(&block); end
  def read_body_rest; end
  def read_header; end
  def receive_timeout; end
  def receive_timeout=(arg0); end
  def requested_version; end
  def requested_version=(arg0); end
  def send_timeout; end
  def send_timeout=(arg0); end
  def set_header(req); end
  def socket_local; end
  def socket_local=(arg0); end
  def socket_sync; end
  def socket_sync=(arg0); end
  def ssl_config; end
  def ssl_config=(arg0); end
  def ssl_peer_cert; end
  def strict_response_size_check; end
  def strict_response_size_check=(arg0); end
  def tcp_keepalive; end
  def tcp_keepalive=(arg0); end
  def test_loopback_http_response; end
  def test_loopback_http_response=(arg0); end
  def transparent_gzip_decompression; end
  def transparent_gzip_decompression=(arg0); end
  include HTTPClient::Timeout
  include HTTPClient::Util
end
class HTTPClient::Session::LenientInflater
  def first_inflate(body); end
  def inflate(body); end
  def initialize; end
end
class HTTPClient::AuthFilterBase
  def parse_authentication_header(res, tag); end
  def parse_challenge_header(challenge); end
end
class HTTPClient::WWWAuth < HTTPClient::AuthFilterBase
  def basic_auth; end
  def digest_auth; end
  def filter_request(req); end
  def filter_response(req, res); end
  def initialize; end
  def negotiate_auth; end
  def oauth; end
  def reset_challenge; end
  def set_auth(uri, user, passwd); end
  def sspi_negotiate_auth; end
end
class HTTPClient::ProxyAuth < HTTPClient::AuthFilterBase
  def basic_auth; end
  def digest_auth; end
  def filter_request(req); end
  def filter_response(req, res); end
  def initialize; end
  def negotiate_auth; end
  def reset_challenge; end
  def set_auth(user, passwd); end
  def sspi_negotiate_auth; end
end
class HTTPClient::AuthBase
  def initialize(scheme); end
  def reset_challenge; end
  def scheme; end
  include HTTPClient::Util
end
class HTTPClient::BasicAuth < HTTPClient::AuthBase
  def challenge(uri, param_str = nil); end
  def force_auth; end
  def force_auth=(arg0); end
  def get(req); end
  def initialize; end
  def lock; end
  def locked?; end
  def set(uri, user, passwd); end
  def set?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  include Mutex_m
end
class HTTPClient::ProxyBasicAuth < HTTPClient::BasicAuth
  def challenge(uri, param_str = nil); end
  def get(req); end
  def set(uri, user, passwd); end
end
class HTTPClient::DigestAuth < HTTPClient::AuthBase
  def calc_cred(req, user, passwd, param); end
  def challenge(uri, param_str); end
  def generate_cnonce; end
  def get(req); end
  def initialize; end
  def lock; end
  def locked?; end
  def parse_challenge_param(param_str); end
  def set(uri, user, passwd); end
  def set?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  include Mutex_m
end
class HTTPClient::ProxyDigestAuth < HTTPClient::DigestAuth
  def challenge(uri, param_str); end
  def get(req); end
  def reset_challenge; end
  def set(uri, user, passwd); end
end
class HTTPClient::NegotiateAuth < HTTPClient::AuthBase
  def challenge(uri, param_str); end
  def get(req); end
  def initialize(scheme = nil); end
  def lock; end
  def locked?; end
  def ntlm_opt; end
  def set(uri, user, passwd); end
  def set?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  include Mutex_m
end
class HTTPClient::SSPINegotiateAuth < HTTPClient::AuthBase
  def challenge(uri, param_str); end
  def get(req); end
  def initialize; end
  def lock; end
  def locked?; end
  def set(*args); end
  def set?; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  include Mutex_m
end
class HTTPClient::OAuth < HTTPClient::AuthBase
  def calc_cred(req, config); end
  def challenge(uri, param_str = nil); end
  def create_base_string(config, header, req); end
  def do_get_config(uri = nil); end
  def encode_header(k, v); end
  def encode_param(params); end
  def escape(str); end
  def generate_nonce; end
  def get(req); end
  def get_config(uri = nil); end
  def initialize; end
  def lock; end
  def locked?; end
  def self.escape(str); end
  def set(*args); end
  def set?; end
  def set_config(uri, config); end
  def sign(config, header, req); end
  def sign_hmac_sha1(config, base_string); end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
  include Mutex_m
end
class HTTPClient::OAuth::Config
  def callback; end
  def callback=(arg0); end
  def consumer_key; end
  def consumer_key=(arg0); end
  def consumer_secret; end
  def consumer_secret=(arg0); end
  def debug_nonce; end
  def debug_nonce=(arg0); end
  def debug_timestamp; end
  def debug_timestamp=(arg0); end
  def http_method; end
  def http_method=(arg0); end
  def initialize(*args); end
  def realm; end
  def realm=(arg0); end
  def secret; end
  def secret=(arg0); end
  def session_handle; end
  def session_handle=(arg0); end
  def signature_handler; end
  def signature_method; end
  def signature_method=(arg0); end
  def token; end
  def token=(arg0); end
  def verifier; end
  def verifier=(arg0); end
  def version; end
  def version=(arg0); end
  include HTTPClient::Util
end
class WebAgent
end
module WebAgent::CookieUtils
  def domain_match(host, domain); end
  def head_match?(str1, str2); end
  def tail_match?(str1, str2); end
end
class WebAgent::Cookie
  def discard=(arg0); end
  def discard?; end
  def domain; end
  def domain=(arg0); end
  def domain_orig=(arg0); end
  def domain_orig?; end
  def expires; end
  def expires=(arg0); end
  def flag; end
  def http_only=(arg0); end
  def http_only?; end
  def initialize; end
  def join_quotedstr(array, sep); end
  def match?(url); end
  def name; end
  def name=(arg0); end
  def normalize_cookie_value(value); end
  def override=(arg0); end
  def override?; end
  def parse(str, url); end
  def path; end
  def path=(arg0); end
  def path_orig=(arg0); end
  def path_orig?; end
  def secure=(arg0); end
  def secure?; end
  def self.parse(str, url); end
  def set_flag(flag); end
  def url; end
  def url=(arg0); end
  def use=(arg0); end
  def use?; end
  def value; end
  def value=(arg0); end
  include WebAgent::CookieUtils
end
class WebAgent::SynchronizedArray < Array
  include MonitorMixin
end
class WebAgent::CookieManager
  def accept_domains; end
  def accept_domains=(arg0); end
  def add(given); end
  def check_cookie_accept_domain(domain); end
  def check_domain(domain, hostname, override); end
  def check_expired_cookies; end
  def cookie_error(err, override); end
  def cookie_value(url); end
  def cookies; end
  def cookies=(cookies); end
  def cookies_file; end
  def cookies_file=(arg0); end
  def find(url); end
  def initialize(file = nil); end
  def load_cookies; end
  def make_cookie_str(cookie_list); end
  def netscape_rule; end
  def netscape_rule=(arg0); end
  def parse(str, url); end
  def reject_domains; end
  def reject_domains=(arg0); end
  def save_all_cookies(force = nil, save_unused = nil, save_discarded = nil); end
  def save_cookies(force = nil); end
  include WebAgent::CookieUtils
end
class WebAgent::CookieManager::Error < StandardError
end
class WebAgent::CookieManager::ErrorOverrideOK < WebAgent::CookieManager::Error
end
class WebAgent::CookieManager::SpecialError < WebAgent::CookieManager::Error
end
class HTTPClient::ConfigurationError < StandardError
end
class HTTPClient::BadResponseError < RuntimeError
  def initialize(msg, res = nil); end
  def res; end
end
class HTTPClient::TimeoutError < RuntimeError
end
class HTTPClient::ConnectTimeoutError < HTTPClient::TimeoutError
end
class HTTPClient::SendTimeoutError < HTTPClient::TimeoutError
end
class HTTPClient::ReceiveTimeoutError < HTTPClient::TimeoutError
end
class HTTPClient::RetryableResponse < StandardError
  def initialize(res = nil); end
  def res; end
end
class HTTPClient::KeepAliveDisconnected < StandardError
  def cause; end
  def initialize(sess = nil, cause = nil); end
  def sess; end
end
