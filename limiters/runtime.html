<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL Enterprise - Rate Limiters - Runtime Limiter</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400,700" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <script>
      function detectDarkTheme(toggle) {
        var prefersDarkSchemeSetting = localStorage.getItem("prefersDarkScheme")
        if (prefersDarkSchemeSetting == null) {
          prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)').matches
        } else {
          prefersDarkScheme = prefersDarkSchemeSetting == "true"
        }

        if (toggle) {
          if (prefersDarkScheme) {
            prefersDarkScheme = false
            localStorage.setItem("prefersDarkScheme", "false")
          } else {
            prefersDarkScheme = true
            localStorage.setItem("prefersDarkScheme", "true")
          }
        }

        if (prefersDarkScheme) {
          document.body.classList.add('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby-dark.png"
          })
        } else {
          document.body.classList.remove('dark-theme');
          document.querySelectorAll(".graphql-ruby-img").forEach(function(el) {
            el.src = "/graphql-ruby.png"
          })
        }
      }

      detectDarkTheme(false)
    </script>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img class="graphql-ruby-img" src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <div class="nav-links">
            <a href="/getting_started">Get Started</a>
            <a href="/guides">Guides</a>
            <a href="/api-doc/2.5.11/">API</a>
            <a href="https://buttondown.email/graphql-ruby">Newsletter</a>
            <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
            <a href="https://graphql.pro">Upgrade to Pro</a>
            <input
              class="search-input"
              onkeyup="GraphQLRubySearch.run(this)"
              type="text"
              placeholder="Search the docs..."
            />
            <a href="#" onclick="event.preventDefault(); detectDarkTheme(true)" class="dark-theme-button"></a>
          </div>
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container  fullwidth ">
      <ul class="breadcrumb">
  <li><a href="/guides">Guides</a></li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/schema/definition.html">Schema</option>
      
        <option  data-target="/queries/executing_queries.html">Queries</option>
      
        <option  data-target="/type_definitions/objects.html">Type Definitions</option>
      
        <option  data-target="/authorization/overview.html">Authorization</option>
      
        <option  data-target="/fields/introduction.html">Fields</option>
      
        <option  data-target="/mutations/mutation_root.html">Mutations</option>
      
        <option  data-target="/errors/overview.html">Errors</option>
      
        <option  data-target="/pagination/overview.html">Pagination</option>
      
        <option  data-target="/relay/range_add.html">Relay</option>
      
        <option  data-target="/dataloader/overview.html">Dataloader</option>
      
        <option  data-target="/subscriptions/overview.html">Subscriptions</option>
      
        <option  data-target="/pro/home.html">GraphQL Pro</option>
      
        <option  data-target="/operation_store/overview.html">GraphQL Pro - OperationStore</option>
      
        <option  data-target="/defer/overview.html">GraphQL Pro - Defer</option>
      
        <option  selected data-target="/limiters/overview.html">GraphQL Enterprise - Rate Limiters</option>
      
        <option  data-target="/object_cache/overview.html">GraphQL Enterprise - Object Cache</option>
      
        <option  data-target="/changesets/overview.html">GraphQL Enterprise - Changesets</option>
      
        <option  data-target="/javascript_client/overview.html">JavaScript Client</option>
      
        <option  data-target="/language_tools/visitor.html">Language Tools</option>
      
        <option  data-target="/testing/overview.html">Testing</option>
      
        <option  data-target="/development.html">Other</option>
      
    </select>
  </li>
  <li>
    <select class="jump-to-select" onchange="navigateToSelected(this)">
      
        <option  data-target="/limiters/overview.html">Rate Limiters for GraphQL</option>
      
        <option  data-target="/limiters/redis.html">Configuring Redis</option>
      
        <option  data-target="/limiters/active_operations.html">Active Operation Limiter</option>
      
        <option  selected data-target="/limiters/runtime.html">Runtime Limiter</option>
      
        <option  data-target="/limiters/deployment.html">Deploying Rate Limiters</option>
      
    </select>
  </li>
</ul>



  <div class="enterprise-header">
    <p>
      <strong>🌟 Enterprise Feature 🌟</strong>
      <span style="font-style: italic;">
        This feature is bundled with <a href="https://graphql.pro/enterprise">GraphQL-Enterprise</a>.
      </span>
    </p>
  </div>

<h1 class="guide-header">Runtime Limiter</h1>
<div class="guide-table-of-contents"><div class="table-of-contents">
  <h3 class="contents-header">Contents</h3>
  <ol class='contents-list'><li class='contents-entry'><a href='#why'>Why?
</a></li><li class='contents-entry'><a href='#setup'>Setup
</a><ol class='contents-list'><li class='contents-entry'><a href='#schema-setup'>Schema Setup
</a></li><li class='contents-entry'><a href='#query-setup'>Query Setup
</a></li></ol></li><li class='contents-entry'><a href='#customization'>Customization
</a></li><li class='contents-entry'><a href='#instrumentation'>Instrumentation
</a></li><li class='contents-entry'><a href='#some-caveats'>Some Caveats
</a></li></ol>
</div>
</div>
<div class="guide-container">
  <p><code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::RuntimeLimiter</code> applies an upper bound to processing time consumed by a single client. It uses <a href="/limiters/redis">Redis</a> track time with a <a href="https://en.wikipedia.org/wiki/Token_bucket">token bucket</a> algorithm.</p>

<h2 id="why">Why?</h2>

<p>This limiter prevents a single client from consuming too much processing time, regardless of whether it comes a burst of short-lived queries (which the <a href="/limiters/active_operations">Active Operation Limiter</a> can prevent) or a small number of long-running queries. Unlike request counters or complexity calculations, the runtime limiter pays no attention to the structure of the incoming request. Instead, it simply measures the time spent on the request <em>as a whole</em> and halts queries when a client consumes more than the limit.</p>

<h2 id="setup">Setup</h2>

<p>To use this limiter, update the schema configuration and include <code class="language-plaintext highlighter-rouge">context[:limiter_key]</code> in your queries.</p>

<h3 id="schema-setup">Schema Setup</h3>

<p>To setup the schema, add <code class="language-plaintext highlighter-rouge">use GraphQL::Enterprise::RuntimeLimiter</code> with a default <code class="language-plaintext highlighter-rouge">limit_ms:</code> value:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span>
  <span class="c1"># ...</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">RuntimeLimiter</span><span class="p">,</span>
    <span class="ss">redis: </span><span class="no">Redis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>
    <span class="ss">limit_ms: </span><span class="mi">90</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1"># 90 seconds per minute</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">limit_ms: false</code> may also be given, which defaults to <em>no limit</em> for this limiter.</p>

<p>It also accepts a <code class="language-plaintext highlighter-rouge">window_ms:</code> option, which is the duration over which <code class="language-plaintext highlighter-rouge">limit_ms:</code> is added to a client’s bucket. It defaults to <code class="language-plaintext highlighter-rouge">60_000</code> (one minute).</p>

<p>Before requests will actually be halted, <a href="/limiters/deployment#soft-limits">soft mode</a> must be disabled.</p>

<h3 id="query-setup">Query Setup</h3>

<p>In order to limit clients, the limiter needs a client identifier for each GraphQL operation. By default, it checks <code class="language-plaintext highlighter-rouge">context[:limiter_key]</code> to find it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">viewer: </span><span class="n">current_user</span><span class="p">,</span>
  <span class="c1"># for example:</span>
  <span class="ss">limiter_key: </span><span class="n">logged_in?</span> <span class="p">?</span> <span class="s2">"user:</span><span class="si">#{</span><span class="n">current_user</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="s2">"</span> <span class="p">:</span> <span class="s2">"anon-ip:</span><span class="si">#{</span><span class="n">request</span><span class="p">.</span><span class="nf">remote_ip</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span>
  <span class="c1"># ...</span>
<span class="p">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">query_str</span><span class="p">,</span> <span class="ss">context: </span><span class="n">context</span><span class="p">)</span>
</code></pre></div></div>

<p>Operations with the same <code class="language-plaintext highlighter-rouge">context[:limiter_key]</code> will rate limited in the same buckets. A limiter key is required; if a query is run without one, the limiter will raise an error.</p>

<p>To provide a client identifier another way, see <a href="#customization">Customization</a>.</p>

<h2 id="customization">Customization</h2>

<p><code class="language-plaintext highlighter-rouge">GraphQL::Enterprise::RuntimeLimiter</code> provides several hooks for customizing its behavior. To use these, make a subclass of the limiter and override methods as described:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/graphql/limiters/runtime.rb</span>
<span class="k">class</span> <span class="nc">Limiters::Runtime</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Enterprise</span><span class="o">::</span><span class="no">RuntimeLimiter</span>
  <span class="c1"># override methods here</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The hooks are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">def limiter_key(query)</code> should return a string which identifies the current client for <code class="language-plaintext highlighter-rouge">query</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">def limit_for(key, query)</code> should return an integer or <code class="language-plaintext highlighter-rouge">nil</code>. If an integer is returned, that limit is applied for the current query. If <code class="language-plaintext highlighter-rouge">nil</code> is returned, no limit is applied to the current query.</li>
  <li><code class="language-plaintext highlighter-rouge">def soft_limit?(key, query)</code> can be implemented to customize the application of “soft mode”. By default, it checks a setting in redis.</li>
  <li><code class="language-plaintext highlighter-rouge">def handle_redis_error(err)</code> is called when the limit rescues an error from Redis. By default, it’s passed to <code class="language-plaintext highlighter-rouge">warn</code> and the query is <em>not</em> halted.</li>
</ul>

<h2 id="instrumentation">Instrumentation</h2>

<p>While the limiter is installed, it adds some information to the query context about its operation. It can be accessed at <code class="language-plaintext highlighter-rouge">context[:runtime_limiter]</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="n">pp</span> <span class="n">result</span><span class="p">.</span><span class="nf">context</span><span class="p">[</span><span class="ss">:runtime_limiter</span><span class="p">]</span>
<span class="c1"># {:key=&gt;"custom-key-9",</span>
<span class="c1">#  :limit_ms=&gt;800,</span>
<span class="c1">#  :remaining_ms=&gt;0,</span>
<span class="c1">#  :soft=&gt;true,</span>
<span class="c1">#  :limited=&gt;true,</span>
<span class="c1">#  :window_ms=&gt;60_000}</span>
</code></pre></div></div>

<p>It returns a Hash containing:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">key: [String]</code>, the limiter key used for this query</li>
  <li><code class="language-plaintext highlighter-rouge">limit_ms: [Integer, nil]</code>, the limit applied to this query</li>
  <li><code class="language-plaintext highlighter-rouge">remaining_ms: [Integer, nil]</code>, the amount of time remaining in this client’s bucket</li>
  <li><code class="language-plaintext highlighter-rouge">soft: [Boolean]</code>, <code class="language-plaintext highlighter-rouge">true</code> if the query was run in “soft mode”</li>
  <li><code class="language-plaintext highlighter-rouge">limited: [Boolean]</code>, <code class="language-plaintext highlighter-rouge">true</code> if the query exceeded the rate limit (but if <code class="language-plaintext highlighter-rouge">soft:</code> was also <code class="language-plaintext highlighter-rouge">true</code>, then the query was <em>not</em> halted)</li>
  <li><code class="language-plaintext highlighter-rouge">window_ms: [Integer]</code> the configured <code class="language-plaintext highlighter-rouge">window_ms:</code> for the limiter</li>
</ul>

<p>You could use this to add detailed metrics to your application monitoring system, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MyMetrics</span><span class="p">.</span><span class="nf">increment</span><span class="p">(</span><span class="s2">"graphql.runtime_limiter"</span><span class="p">,</span> <span class="ss">tags: </span><span class="n">result</span><span class="p">.</span><span class="nf">context</span><span class="p">[</span><span class="ss">:runtime_limiter</span><span class="p">])</span>
</code></pre></div></div>

<h2 id="some-caveats">Some Caveats</h2>

<p>The limiter will not <em>interrupt</em> a long-running field. Instead, it stops executing new fields after a client exceeds its allowed processing time. This is because interrupting arbitrary code may have unintended consequences for I/O operations, see <a href="https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/">“Timeout: Ruby’s most dangerous API”</a>.</p>

<p>Also, the limiter only checks remaining time at the <em>start</em> of a query and it only decreases the remaining time at the <em>end</em> of a query. This means that simulaneous queries may consume the remainder at the same time. Use the <a href="/limiters/active_operations">Active Operation Limiter</a> to limit behavior in this regard. This implementation is basically a trade-off: more granular updates would require more communication with Redis which would add overhead to each request.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/limiters/runtime.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Runtime Limiter">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
  function navigateToSelected(selectElement) {
    var nextPage = selectElement.selectedOptions[0].dataset["target"]
    document.location = nextPage
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
    <script>
      detectDarkTheme(false) // do it again to update the images
    </script>
  </body>
</html>
