<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta http-equiv="refresh" content="1;url=/api-doc/1.10.6/GraphQL/Schema/TimeoutMiddleware" />
  </head>
  <body>
    <p>Class: GraphQL::Schema::TimeoutMiddleware &lt; Object
This middleware will stop resolving new fields after <code class="highlighter-rouge">max_seconds</code>
have elapsed. After the time has passed, any remaining fields will
be <code class="highlighter-rouge">nil</code>, with errors added to the <code class="highlighter-rouge">errors</code> key. Any
already-resolved fields will be in the <code class="highlighter-rouge">data</code> key, so you’ll get a
partial response. 
You can provide a block which will be called with any timeout errors
that occur. 
Note that this will stop a query <em>in between</em> field resolutions, but
it doesn’t interrupt long-running <code class="highlighter-rouge">resolve</code> functions. Be sure to
use timeout options for external connections. For more info, see
www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/ 
Examples:</p>
<h1 id="stop-resolving-fields-after-2-seconds">Stop resolving fields after 2 seconds</h1>
<p>MySchema.middleware « GraphQL::Schema::TimeoutMiddleware.new(max_seconds: 2)</p>
<h1 id="notifying-bugsnag-on-a-timeout">Notifying Bugsnag on a timeout</h1>
<p>MySchema.middleware « GraphQL::Schema::TimeoutMiddleware(max_seconds: 1.5) do |timeout_error, query|
Bugsnag.notify(timeout_error, {query_string: query_ctx.query.query_string})
end
Instance methods:
call, initialize, on_timeout</p>


  </body>
</html>
