<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Interpreter</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="/api-doc/1.10.6/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <a href="https://graphql.pro">Upgrade to Pro</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results">
        </div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#queries-guides">Queries</a>
  &raquo; Interpreter
</p>


<h1 class="guide-header">Interpreter</h1>
<div class="guide-container">
  <p>GraphQL-Ruby 1.9.0 includes a new runtime module which you may use for your schema. Eventually, it will become the default.</p>

<p>It‚Äôs called <code class="highlighter-rouge">GraphQL::Execution::Interpreter</code> and you can hook it up with <code class="highlighter-rouge">use ...</code> in your schema class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Execution</span><span class="o">::</span><span class="no">Interpreter</span>
  <span class="c1"># And, when you have updated your analyzers:</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">AST</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Read on to learn more!</p>

<h2 id="rationale">Rationale</h2>

<p>The new runtime was added to address a few specific concerns:</p>

<ul>
  <li><strong>Validation Performance</strong>: The previous runtime depended on a preparation step (<code class="highlighter-rouge">GraphQL::InternalRepresentation::Rewrite</code>) which could be very slow in some cases. In many cases, the overhead of that step provided no value.</li>
  <li><strong>Runtime Performance</strong>: For very large results, the previous runtime was slow because it allocated a new <code class="highlighter-rouge">ctx</code> object for every field, even very simple fields that didn‚Äôt need any special tracking.</li>
  <li><strong>Extensibility</strong>: Although the GraphQL specification supports custom directives, GraphQL-Ruby didn‚Äôt have a good way to build them.</li>
</ul>

<h2 id="installation">Installation</h2>

<p>You can opt in to the interpreter in your schema class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Schema</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Execution</span><span class="o">::</span><span class="no">Interpreter</span>
  <span class="c1"># And, after you have updated your analyzers:</span>
  <span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">AST</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you have a subscription root type, it will also need an update. Extend this new module:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Types</span><span class="o">::</span><span class="no">Subscription</span> <span class="o">&lt;</span> <span class="no">Types</span><span class="o">::</span><span class="no">BaseObject</span>
  <span class="c1"># Extend this module to support subscription root fields with Interpreter</span>
  <span class="kp">extend</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Subscriptions</span><span class="o">::</span><span class="no">SubscriptionRoot</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Some Relay configurations must be updated too. For example:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">- field :node, field: GraphQL::Relay::Node.field
</span><span class="gi">+ add_field(GraphQL::Types::Relay::NodeField)
</span></code></pre></div></div>

<p>(Alternatively, consider implementing <code class="highlighter-rouge">Query.node</code> in your own app, using <code class="highlighter-rouge">NodeField</code> as inspiration.)</p>

<h2 id="compatibility">Compatibility</h2>

<p>The new runtime works with class-based schemas only. Several features are no longer supported:</p>

<ul>
  <li>
    <p>Proc-dependent field features:</p>

    <ul>
      <li>Field Instrumentation</li>
      <li>Middleware</li>
      <li>Resolve procs</li>
      <li><code class="highlighter-rouge">GraphQL::Function</code></li>
    </ul>

    <p>All these depend on the memory- and time-hungry per-field <code class="highlighter-rouge">ctx</code> object. To improve performance, only method-based resolves are supported. If need something from <code class="highlighter-rouge">ctx</code>, you can get it with the <code class="highlighter-rouge">extras: [...]</code> configuration option. To wrap resolve behaviors, try <a href="/type_definitions/field_extensions">Field Extensions</a>, <a href="/queries/tracing">Tracing</a>, or <a href="/fields/resolvers">GraphQL::Schema::Resolver</a>.</p>
  </li>
  <li>
    <p>Query analyzers and <code class="highlighter-rouge">irep_node</code>s</p>

    <p>These depend on the now-removed <code class="highlighter-rouge">Rewrite</code> step, which wasted a lot of time making often-unneeded preparation. Most of the attributes you might need from an <code class="highlighter-rouge">irep_node</code> are available with <code class="highlighter-rouge">extras: [...]</code>. Query analyzers can be refactored to be static checks (custom validation rules) or dynamic checks, made at runtime. The built-in analyzers have been refactored to run as validators.</p>

    <p>For a replacement, check out:</p>

    <ul>
      <li><a href="/api-doc/1.10.6/GraphQL/Execution/Lookahead" target="_blank" title="API docs for GraphQL::Execution::Lookahead"><code>GraphQL::Execution::Lookahead</code></a> for field-level info about child selections</li>
      <li><a href="/api-doc/1.10.6/GraphQL/Analysis/AST" target="_blank" title="API docs for GraphQL::Analysis::AST"><code>GraphQL::Analysis::AST</code></a> for query analysis which is compatible with the new interpreter</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">rescue_from</code></p>

    <p>This was built on middleware, which is not supported anymore. For a replacement, see <a href="/errors/error_handling">Error Handling</a>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">.graphql_definition</code> and <code class="highlighter-rouge">def to_graphql</code></p>

    <p>The interpreter uses class-based schema definitions only, and never converts them to legacy GraphQL definition objects. Any custom definitions to GraphQL objects should be re-implemented on custom base classes.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">GraphQL::Schema::Field#resolve_field</code></p>

    <p>If you customized your base field‚Äôs resolution method, it needs an update. The interpreter calls a different method: <code class="highlighter-rouge">#resolve(obj, args, ctx)</code>. There are two differences with the new method:</p>

    <ul>
      <li><code class="highlighter-rouge">args</code> is plain ol‚Äô Ruby Hash, with symbol keys, instead of a <code class="highlighter-rouge">GraphQL::Query::Arguments</code></li>
      <li><code class="highlighter-rouge">ctx</code> is a <code class="highlighter-rouge">GraphQL::Query::Context</code> instead of a <code class="highlighter-rouge">GraphQL::Query::Context::FieldResolutionContext</code></li>
    </ul>

    <p>But besides that, it‚Äôs largely the same.</p>
  </li>
</ul>

<p>Maybe this section should have been called <em>incompatibility</em> ü§î.</p>

<h2 id="extending-the-runtime">Extending the Runtime</h2>

<p>See <a href="/type_definitions/directives">Directives</a>.</p>

<h2 id="analyzers">Analyzers</h2>

<p>GraphQL-Ruby has ‚Äúanalyzers‚Äù that run <em>before</em> execution and may reject a query. With the interpreter, you can use <a href="/queries/ast_analysis">AST Analyzers</a> to get better performance.</p>

<p>To make the migration, convert your previous analyzers to extend <a href="/api-doc/1.10.6/GraphQL/Analysis/AST/Analyzer" target="_blank" title="API docs for GraphQL::Analysis::AST::Analyzer"><code>GraphQL::Analysis::AST::Analyzer</code></a> as described in the guide, then add to your schema:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">Analysis</span><span class="o">::</span><span class="no">AST</span>
</code></pre></div></div>

<p>When you use <em>both</em> <code class="highlighter-rouge">Interpreter</code> and <code class="highlighter-rouge">Analysis::AST</code>, GraphQL-Ruby will skip the slow process of building <code class="highlighter-rouge">irep_nodes</code>.</p>

<p>All analyzers must be migrated at once; running <em>some</em> legacy analyzers and <em>some</em> AST analyzers is not supported.</p>

<p>You can migrate to <code class="highlighter-rouge">Interpreter</code> before migrating to <code class="highlighter-rouge">Analysis::AST</code>. In that case, the <code class="highlighter-rouge">irep_node</code> tree will still be constructed and used for analysis, even though it will not be used for execution.</p>

<h2 id="implementation-notes">Implementation Notes</h2>

<p>Instead of a tree of <code class="highlighter-rouge">irep_nodes</code>, the interpreter consumes the AST directly. This removes a complicated concept from GraphQL-Ruby (<code class="highlighter-rouge">irep_node</code>s) and simplifies the query lifecycle. The main difference relates to how fragment spreads are resolved. In the previous runtime, the possible combinations of fields for a given object were calculated ahead of time, then some of those combinations were used during runtime, but many of them may not have been. In the new runtime, no precalculation is made; instead each object is checked against each fragment at runtime.</p>

<p>Instead of creating a <code class="highlighter-rouge">GraphQL::Query::Context::FieldResolutionContext</code> for <em>every</em> field in the response, the interpreter uses long-lived, mutable objects for execution bookkeeping. This is more complicated to manage, since the changes to those objects can be hard to predict, but it‚Äôs worth it for the performance gain. When needed, those bookkeeping objects can be ‚Äúforked‚Äù, so that two parts of an operation can be resolved independently.</p>

<p>Instead of calling <code class="highlighter-rouge">.to_graphql</code> internally to convert class-based definitions to <code class="highlighter-rouge">.define</code>-based definitions, the interpreter operates on class-based definitions directly. This simplifies the workflow for creating custom configurations and using them at runtime.</p>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/queries/interpreter.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Interpreter">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
