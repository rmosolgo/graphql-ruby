<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <title>GraphQL - Testing</title>
    
    <link href="https://fonts.googleapis.com/css?family=Rubik:300,400" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css">
    <link rel="icon" href="/graphql-ruby-icon.png">
  </head>
  <body>
    <div class="header">
      <div class="header-container">
        <div class="nav">
          <a href="/" class="img-link">
            <img src="/graphql-ruby.png" alt="GraphQL Ruby Logo" />
          </a>
          <a href="/getting_started">Get Started</a>
          <a href="/guides">Guides</a>
          <a href="http://www.rubydoc.info/gems/graphql/1.8.0.pre11/">API</a>
          <a href="https://tinyletter.com/graphql-ruby">Newsletter</a>
          <a href="https://github.com/rmosolgo/graphql-ruby">Source Code</a>
          <input
            class="search-input"
            onkeyup="GraphQLRubySearch.run(this)"
            type="text"
            placeholder="Search the docs..."
          />
        </div>
      </div>
      <div class="search-results-container">
        <div id="search-results"></div>
      </div>
    </div>
    <div class="container">
      <p class="breadcrumb">
  <a href="/">GraphQL</a>
  &raquo; <a href="/guides">Guides</a>
   &raquo; <a href="/guides#schema-guides">Schema</a>
  &raquo; Testing
</p>



<h1 class="guide-header">Testing</h1>
<div class="guide-container">
  <p>There are a few ways to test the behavior of your GraphQL schema:</p>

<ul>
  <li><em>Don’t</em> test the schema, test other objects instead</li>
  <li>Test schema elements (types, fields) in isolation</li>
  <li>Execute GraphQL queries and test the result</li>
</ul>

<h2 id="dont-test-the-schema">Don’t test the schema</h2>

<p>The easiest way to test behavior of a GraphQL schema is to extract behavior into separate objects and test those objects in isolation. For Rails, you don’t test your models by running controller tests, right? Similarly, you can test “lower-level” parts of the system on their own without running end-to-end tests.</p>

<p>For example, consider a field which calculates its own value:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">PostType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">field</span> <span class="ss">:isTrending</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">recent_comments</span> <span class="o">=</span> <span class="n">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
      <span class="n">recent_comments</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="mi">100</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>You can refactor this by creating a new class and applying it to your GraphQL schema:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post/trending.rb</span>
<span class="k">class</span> <span class="nc">Post</span>
  <span class="k">class</span> <span class="nc">Trending</span>
    <span class="no">TRENDING_COMMENTS_COUNT</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
      <span class="vi">@post</span> <span class="o">=</span> <span class="n">post</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">value</span>
      <span class="n">recent_comments</span> <span class="o">=</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"created_at &lt; ?"</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="nf">day</span><span class="p">.</span><span class="nf">ago</span><span class="p">)</span>
      <span class="n">recent_comments</span><span class="p">.</span><span class="nf">count</span> <span class="o">&gt;</span> <span class="no">TRENDING_COMMENTS_COUNT</span>       
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># ....</span>

<span class="no">PostType</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">ObjectType</span><span class="p">.</span><span class="nf">define</span> <span class="k">do</span>
  <span class="c1"># ...</span>
  <span class="n">field</span> <span class="ss">:isTrending</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="no">Boolean</span> <span class="k">do</span>
    <span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1"># Use the Post::Trending class to calculate the value</span>
      <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">obj</span><span class="p">).</span><span class="nf">value</span>
    <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is an improvement because your behavior is not coupled to your GraphQL schema. Besides that, it’s easier to test: you can simply unit test the calculation class. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post/trending_spec.rb</span>
<span class="n">describe</span> <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:post</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:trending</span><span class="p">)</span> <span class="p">{</span> <span class="no">Post</span><span class="o">::</span><span class="no">Trending</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">post</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"#value"</span> <span class="k">do</span>
    <span class="n">context</span> <span class="s2">"when there are no recent comments"</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s2">"is false"</span> <span class="k">do</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">trending</span><span class="p">.</span><span class="nf">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s2">"when there are more than 100 recent comments"</span> <span class="k">do</span>
      <span class="n">before</span> <span class="k">do</span>
        <span class="mi">101</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">create</span><span class="p">(</span><span class="ss">:comment</span><span class="p">,</span> <span class="ss">post: </span><span class="n">post</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>

      <span class="n">it</span> <span class="s2">"is true"</span> <span class="k">do</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">trending</span><span class="p">.</span><span class="nf">value</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="testing-schema-elements-in-isolation">Testing schema elements in isolation</h2>

<p>You can access type and field objects from your schema to make sure they’re defined correctly and behave the way you expect them to.</p>

<h4 id="types">Types</h4>

<p>Access a type by name from the schema with <code class="highlighter-rouge">GraphQL::Schema#types</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">post</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">[</span><span class="s2">"Post"</span><span class="p">]</span> <span class="c1"># =&gt; PostType</span>
<span class="n">post</span><span class="p">.</span><span class="nf">fields</span>                   <span class="c1"># =&gt; {"id" =&gt; &lt;GraphQL::Field&gt;, ... }</span>
<span class="n">post</span><span class="p">.</span><span class="nf">fields</span><span class="p">.</span><span class="nf">keys</span>              <span class="c1"># =&gt; ["id", "title", "body", "author", "comments"]</span>
</code></pre></div></div>

<p>The returned value of <code class="highlighter-rouge">Schema#types[type_name]</code> is an instance of the type class you used to <code class="highlighter-rouge">.define</code> it (eg, <code class="highlighter-rouge">GraphQL::ObjectType</code>, <code class="highlighter-rouge">GraphQL::EnumType</code>, <code class="highlighter-rouge">GraphQL::InputObjectType</code>).</p>

<h4 id="fields">Fields</h4>

<p>You can get a type’s fields from the <code class="highlighter-rouge">GraphQL::ObjectType#fields</code> hash. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">post_type</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">types</span><span class="p">[</span><span class="s2">"Post"</span><span class="p">]</span>
<span class="n">title_field</span> <span class="o">=</span> <span class="n">post_type</span><span class="p">.</span><span class="nf">fields</span><span class="p">[</span><span class="s2">"title"</span><span class="p">]</span> <span class="c1">#=&gt; &lt;GraphQL::Field&gt;</span>
<span class="n">title_field</span><span class="p">.</span><span class="nf">name</span> <span class="c1">#=&gt; "title"</span>
</code></pre></div></div>

<p>You can test a resolve function by calling <code class="highlighter-rouge">GraphQL::Field#resolve</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Because this field doesn't use context or variables, simply pass `nil`</span>
<span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Welcome to my blog"</span><span class="p">)</span>
<span class="n">name_field</span><span class="p">.</span><span class="nf">resolve</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1">#=&gt; "Welcome to my blog"</span>
</code></pre></div></div>

<p>Calling <code class="highlighter-rouge">resolve</code> in this way does <em>not</em> apply any coercion. (That’s only applied during query execution.)</p>

<h4 id="other-elements">Other elements</h4>

<p>Similarly, you can access:</p>

<ul>
  <li><code class="highlighter-rouge">GraphQL::Field#arguments</code>, which are <code class="highlighter-rouge">String</code> =&gt; <code class="highlighter-rouge">GraphQL::Argument</code> pairs</li>
  <li><code class="highlighter-rouge">GraphQL::Field#type</code>, the field’s return type</li>
  <li><code class="highlighter-rouge">GraphQL::InputObjectType#arguments</code>, which are <code class="highlighter-rouge">String</code> =&gt; <code class="highlighter-rouge">GraphQL::Argument</code> pairs</li>
  <li><code class="highlighter-rouge">GraphQL::EnumType#values</code>, which are <code class="highlighter-rouge">String</code> =&gt; <code class="highlighter-rouge">GraphQL::EnumType::EnumValue</code> pairs</li>
  <li><code class="highlighter-rouge">GraphQL::Schema#possible_types(type_defn)</code>, which returns the possible types for union or interface types in a given schema</li>
</ul>

<p><code class="highlighter-rouge">GraphQL::BaseType#unwrap</code> may also be helpful. It returns the “inner-most” type. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">required_list_of_strings</span> <span class="o">=</span> <span class="no">GraphQL</span><span class="o">::</span><span class="no">NonNullType</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
  <span class="ss">of_type: </span><span class="no">GraphQL</span><span class="o">::</span><span class="no">ListType</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="ss">of_type: </span><span class="no">GraphQL</span><span class="o">::</span><span class="no">STRING_TYPE</span>
  <span class="p">)</span>
<span class="p">)</span>

<span class="n">required_list_of_strings</span><span class="p">.</span><span class="nf">unwrap</span> <span class="c1">#=&gt; GraphQL::STRING_TYPE</span>
</code></pre></div></div>

<h2 id="executing-graphql-queries">Executing GraphQL queries</h2>

<p>Sometimes, you really need an end-to-end test. Although it requires a lot of overhead, it’s nice to have a “sanity check” on the system as a whole.</p>

<p>You can execute queries on your schema in a test. For example, you can set it up like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">describe</span> <span class="no">MySchema</span> <span class="k">do</span>
  <span class="c1"># You can override `context` or `variables` in</span>
  <span class="c1"># more specific scopes</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:context</span><span class="p">)</span> <span class="p">{</span> <span class="p">{}</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:variables</span><span class="p">)</span> <span class="p">{</span> <span class="p">{}</span> <span class="p">}</span>
  <span class="c1"># Call `result` to execute the query</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:result</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span> <span class="o">=</span> <span class="no">MySchema</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span>
      <span class="n">query_string</span><span class="p">,</span>
      <span class="ss">context: </span><span class="n">context</span><span class="p">,</span>
      <span class="ss">variables: </span><span class="n">variables</span>
    <span class="p">)</span>
    <span class="c1"># Print any errors</span>
    <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="s2">"errors"</span><span class="p">]</span>
      <span class="n">pp</span> <span class="n">res</span>
    <span class="k">end</span>
    <span class="n">res</span>
  <span class="p">}</span>

  <span class="n">describe</span> <span class="s2">"a specific query"</span> <span class="k">do</span>
    <span class="c1"># provide a query string for `result`</span>
    <span class="n">let</span><span class="p">(</span><span class="ss">:query_string</span><span class="p">)</span> <span class="p">{</span> <span class="sx">%|{ viewer { name } }|</span> <span class="p">}</span>

    <span class="n">context</span> <span class="s2">"when there's no current user"</span> <span class="k">do</span>
      <span class="n">it</span> <span class="s2">"is nil"</span> <span class="k">do</span>
        <span class="c1"># calling `result` executes the query</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s2">"data"</span><span class="p">][</span><span class="s2">"viewer"</span><span class="p">]).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">context</span> <span class="s2">"when there's a current user"</span> <span class="k">do</span>
      <span class="c1"># override `context`</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:context</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="ss">current_user: </span><span class="no">User</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"ABC"</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">it</span> <span class="s2">"shows the user's name"</span> <span class="k">do</span>
        <span class="n">user_name</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"data"</span><span class="p">][</span><span class="s2">"viewer"</span><span class="p">][</span><span class="s2">"name"</span><span class="p">]</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">user_name</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="s2">"ABC"</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

</div>
<p class="guide-footer">
  Suggestion, improvement, or correction?
  <a href="https://github.com/rmosolgo/graphql-ruby/edit/master/guides/schema/testing.md">Edit this file</a> or
  <a href="https://github.com/rmosolgo/graphql-ruby/issues/new?title=Guide: Testing">report an issue</a>.
</p>
<script>
  // Find headers with IDs and wrap their text in `<a href=></a>`
  // That way people can easily copy the link.
  var headers = document.querySelectorAll("h1, h2, h3, h4, h5");
  var header, idText, headerLink;
  for (var i = 0; i < headers.length; i++) {
    header = headers[i];
    idText = header.id;
    if (idText) {
      headerLink = document.createElement("a");
      headerLink.href = "#" + idText;
      headerLink.textContent = header.textContent;
      header.textContent = "";
      header.appendChild(headerLink);
    }
  }
</script>

    </div>
    <script src="https://cdn.jsdelivr.net/algoliasearch/3/algoliasearchLite.min.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
