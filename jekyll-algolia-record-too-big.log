{
  "html": "<p><a href=\"https://graphql.pro\">GraphQL Pro</a> includes a subscription system based on <a href=\"https://redis.io\">Redis</a> and <a href=\"https://ably.io\">Ably</a> which works with any Ruby web framework.</p>",
  "content": "GraphQL Pro includes a subscription system based on Redis and Ably which works with any Ruby web framework.",
  "headings": [

  ],
  "custom_ranking": {
    "position": 0,
    "heading": 100
  },
  "doc_stub": false,
  "search": true,
  "section": "Subscriptions",
  "title": "Ably Implementation",
  "desc": "GraphQL subscriptions over Ably",
  "index": 7,
  "pro": true,
  "section_pages": [
    "<p><em>Subscriptions</em> allow GraphQL clients to observe specific events and receive updates from the server when those events occur. This supports live updates, such as websocket pushes. Subscriptions introduce several new concepts:</p>\n\n<ul>\n  <li>The <strong>Subscription type</strong> is the entry point for subscription queries</li>\n  <li><strong>Subscription classes</strong> are resolvers for handing initial subscription requests and subsequent updates</li>\n  <li><strong>Triggers</strong> begin the update process</li>\n  <li>The <strong>Implementation</strong> provides application-specific methods for executing &amp; delivering updates.</li>\n  <li><strong>Broadcasts</strong> can send the same GraphQL result to any number of subscribers.</li>\n</ul>\n\n<h2 id=\"subscription-type\">Subscription Type</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">subscription</code> is an entry point to your GraphQL schema, like <code class=\"language-plaintext highlighter-rouge\">query</code> or <code class=\"language-plaintext highlighter-rouge\">mutation</code>. It is defined by your <code class=\"language-plaintext highlighter-rouge\">SubscriptionType</code>, a root-level <code class=\"language-plaintext highlighter-rouge\">GraphQL::Schema::Object</code>.</p>\n\n<p>Read more in the <a href=\"/subscriptions/subscription_type\">Subscription Type guide</a>.</p>\n\n<h2 id=\"subscription-classes\">Subscription Classes</h2>\n\n<p><a href=\"/api-doc/2.0.0/GraphQL/Schema/Subscription\" target=\"_blank\" title=\"API docs for GraphQL::Schema::Subscription\"><code>GraphQL::Schema::Subscription</code></a> is a resolver class with subscription-specific behaviors. Each subscription field should be implemented by a subscription class.</p>\n\n<p>Read more in the <a href=\"/subscriptions/subscription_classes\">Subscription Classes guide</a></p>\n\n<h2 id=\"triggers\">Triggers</h2>\n\n<p>After an event occurs in our application, <em>triggers</em> begin the update process by sending a name and payload to GraphQL.</p>\n\n<p>Read more in the <a href=\"/subscriptions/triggers\">Triggers guide</a>.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>Besides the GraphQL component, your application must provide some subscription-related plumbing, for example:</p>\n\n<ul>\n  <li><strong>state management</strong>: How does your application keep track of who is subscribed to what?</li>\n  <li><strong>transport</strong>: How does your application deliver payloads to clients?</li>\n  <li><strong>queueing</strong>: How does your application distribute the work of re-running subscription queries?</li>\n</ul>\n\n<p>Read more in the <a href=\"/subscriptions/implementation\">Implementation guide</a> or check out the <a href=\"/subscriptions/action_cable_implementation\">ActionCable implementation</a>, <a href=\"/subscriptions/pusher_implementation\">Pusher implementation</a> or <a href=\"/subscriptions/ably_implementation\">Ably implementation</a>.</p>\n\n<h2 id=\"broadcasts\">Broadcasts</h2>\n\n<p>By default, the subscription implementations listed above handle each subscription in total isolation. However, this behavior can be optimized by setting up broadcasts. Read more in the <a href=\"/subscriptions/broadcast\">Broadcast guide</a>.</p>\n\n<h2 id=\"multi-tenant\">Multi-Tenant</h2>\n\n<p>See the <a href=\"/subscriptions/multi_tenant\">Multi-tenant guide</a> for supporting multi-tenancy in GraphQL subscriptions.</p>\n",
    "<p>You can extend <a href=\"/api-doc/2.0.0/GraphQL/Schema/Subscription\" target=\"_blank\" title=\"API docs for GraphQL::Schema::Subscription\"><code>GraphQL::Schema::Subscription</code></a> to create fields that can be subscribed to.</p>\n\n<p>These classes support several behaviors:</p>\n\n<ul>\n  <li><a href=\"#check-permissions-with-authorized\">Authorizing</a> (or rejecting) initial subscription requests and subsequent updates</li>\n  <li>Returning values for <a href=\"#initial-subscription-with-subscribe\">initial subscription requests</a></li>\n  <li><a href=\"#terminating-the-subscription-with-unsubscribe\">Unsubscribing</a> from the server</li>\n  <li>Implicitly <a href=\"#scope\">scoping updates</a>, to direct data to the right subscriber</li>\n  <li><a href=\"#subsequent-updates-with-update\">Skipping updates</a> for certain clients (eg, don’t send updates to the person who triggered the event)</li>\n</ul>\n\n<p>Continue reading to set up subscription classes.</p>\n\n<h2 id=\"add-a-base-class\">Add a base class</h2>\n\n<p>First, add a base class for your application. You can hook up your base classes there:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># app/graphql/subscriptions/base_subscription.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Subscriptions::BaseSubscription</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">::</span><span class=\"no\">Subscription</span>\n  <span class=\"c1\"># Hook up base classes</span>\n  <span class=\"n\">object_class</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">BaseObject</span>\n  <span class=\"n\">field_class</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">BaseField</span>\n  <span class=\"n\">argument_class</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">BaseArgument</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>(This base class is a lot like the <a href=\"/mutations/mutation_classes\">mutation base class</a>. They’re both subclasses of <a href=\"/api-doc/2.0.0/GraphQL/Schema/Resolver\" target=\"_blank\" title=\"API docs for GraphQL::Schema::Resolver\"><code>GraphQL::Schema::Resolver</code></a>.)</p>\n\n<h2 id=\"extend-the-base-class-and-hook-it-up\">Extend the base class and hook it up</h2>\n\n<p>Define a class for each subscribable event in your system. For example, if you run a chat room, you might publish events whenever messages are posted in a room:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># app/graphql/subscriptions/message_was_posted.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Subscriptions::MessageWasPosted</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then, hook up the new class to the <a href=\"/subscriptions/subscription_type\">Subscription root type</a> with the <code class=\"language-plaintext highlighter-rouge\">subscription:</code> option:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Types::SubscriptionType</span> <span class=\"o\">&lt;</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">BaseObject</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:message_was_posted</span><span class=\"p\">,</span> <span class=\"ss\">subscription: </span><span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">MessageWasPosted</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Now, it will be accessible as:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">messageWasPosted</span><span class=\"p\">(</span><span class=\"n\">roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"abcd\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"c\"># ...</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<h2 id=\"arguments\">Arguments</h2>\n\n<p>Subscription fields take <a href=\"/fields/arguments\">arguments</a> just like normal fields. They also accept a <a href=\"/mutations/mutation_classes#auto-loading-arguments\"><code class=\"language-plaintext highlighter-rouge\">loads:</code> option</a> just like mutations. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::MessageWasPosted</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"c1\"># `room_id` loads a `room`</span>\n  <span class=\"n\">argument</span> <span class=\"ss\">:room_id</span><span class=\"p\">,</span> <span class=\"no\">ID</span><span class=\"p\">,</span> <span class=\"ss\">loads: </span><span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">RoomType</span>\n\n  <span class=\"c1\"># It's passed to other methods as `room`</span>\n  <span class=\"k\">def</span> <span class=\"nf\">subscribe</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">:)</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">:)</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This can be invoked as</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"p\">(</span><span class=\"nv\">$roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">ID</span><span class=\"p\">!)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">messageWasPosted</span><span class=\"p\">(</span><span class=\"n\">roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nv\">$roomId</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"c\"># ...</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>If the ID doesn’t find an object, then the subscription will be unsubscribed (with <code class=\"language-plaintext highlighter-rouge\">#unsubscribe</code>, see below).</p>\n\n<h2 id=\"fields\">Fields</h2>\n\n<p>Like mutations, you can use a generated return type for subscriptions. When you add <code class=\"language-plaintext highlighter-rouge\">field(...)</code>s to a subscription, they’ll be added to the subscription’s generated return type. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::MessageWasPosted</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:room</span><span class=\"p\">,</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">RoomType</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:message</span><span class=\"p\">,</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">MessageType</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>will generate:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"n\">MessageWasPostedPayload</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">room</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Room</span><span class=\"p\">!</span><span class=\"w\">\n  </span><span class=\"n\">message</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Message</span><span class=\"p\">!</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>Which you can use in queries like:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"p\">(</span><span class=\"nv\">$roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">ID</span><span class=\"p\">!)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">messageWasPosted</span><span class=\"p\">(</span><span class=\"n\">roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nv\">$roomId</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"n\">room</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">name</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n    </span><span class=\"n\">message</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">author</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n        </span><span class=\"n\">handle</span><span class=\"w\">\n      </span><span class=\"p\">}</span><span class=\"w\">\n      </span><span class=\"n\">body</span><span class=\"w\">\n      </span><span class=\"n\">postedAt</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>If you remove <code class=\"language-plaintext highlighter-rouge\">null: false</code>, then you can return different data in the initial subscription and the subsequent updates. (See lifecycle methods below.)</p>\n\n<p>Instead of a generated type, you can provide an already-configured type with <code class=\"language-plaintext highlighter-rouge\">payload_type</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Just return a message</span>\n<span class=\"n\">payload_type</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">MessageType</span>\n</code></pre></div></div>\n\n<p>(In that case, don’t return a hash from <code class=\"language-plaintext highlighter-rouge\">#subscribe</code> or <code class=\"language-plaintext highlighter-rouge\">#update</code>, return a <code class=\"language-plaintext highlighter-rouge\">message</code> object instead.)</p>\n\n<h2 id=\"scope\">Scope</h2>\n\n<p>Usually, GraphQL-Ruby uses explicitly-passed arguments to determine when a <a href=\"/subscriptions/triggers\">trigger</a> applies to an active subscription. But, you can use <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> to configure <em>implicit</em> conditions on updates. When <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> is configured, only triggers with a matching <code class=\"language-plaintext highlighter-rouge\">scope:</code> value will cause clients to receive updates.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> accepts a symbol and the given symbol will be looked up in <code class=\"language-plaintext highlighter-rouge\">context</code> to find a scope value.</p>\n\n<p>For example, this subscription will use <code class=\"language-plaintext highlighter-rouge\">context[:current_organization_id]</code> as a scope:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::EmployeeHired</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">subscription_scope</span> <span class=\"ss\">:current_organization_id</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Clients subscribe <em>without</em> any arguments:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">employeeHired</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"n\">hireDate</span><span class=\"w\">\n    </span><span class=\"n\">employee</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">name</span><span class=\"w\">\n      </span><span class=\"n\">department</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>But <code class=\"language-plaintext highlighter-rouge\">.trigger</code>s are routed using <code class=\"language-plaintext highlighter-rouge\">scope:</code>. So, if the subscriber’s context includes <code class=\"language-plaintext highlighter-rouge\">current_organization_id: 100</code>, then the trigger must include the same <code class=\"language-plaintext highlighter-rouge\">scope:</code> value:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"no\">MyAppSchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">trigger</span><span class=\"p\">(</span>\n  <span class=\"c1\"># Field name</span>\n  <span class=\"ss\">:employee_hired</span><span class=\"p\">,</span>\n  <span class=\"c1\"># Arguments</span>\n  <span class=\"p\">{},</span>\n  <span class=\"c1\"># Object</span>\n  <span class=\"p\">{</span> <span class=\"ss\">hire_date: </span><span class=\"no\">Time</span><span class=\"p\">.</span><span class=\"nf\">now</span><span class=\"p\">,</span> <span class=\"ss\">employee: </span><span class=\"n\">new_employee</span> <span class=\"p\">},</span>\n  <span class=\"c1\"># This corresponds to `context[:current_organization_id]`</span>\n  <span class=\"c1\"># in the original subscription:</span>\n  <span class=\"ss\">scope: </span><span class=\"mi\">100</span>\n <span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Scope is also used for determining whether subscribers can receive the same <a href=\"/subscriptions/implementation#broadcast\">broadcast</a>.</p>\n\n<h2 id=\"check-permissions-with-authorized\">Check Permissions with #authorized?</h2>\n\n<p>Suppose a client is subscribing to messages in a chat room:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"p\">(</span><span class=\"nv\">$roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">ID</span><span class=\"p\">!)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">messageWasPosted</span><span class=\"p\">(</span><span class=\"n\">roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nv\">$roomId</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"n\">message</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">author</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">handle</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\">\n      </span><span class=\"n\">body</span><span class=\"w\">\n      </span><span class=\"n\">postedAt</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>You can implement <code class=\"language-plaintext highlighter-rouge\">#authorized?</code> to check that the user has permission to subscribe to these arguments (and receive updates for these arguments), for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">authorized?</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">:)</span>\n  <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"ss\">:viewer</span><span class=\"p\">].</span><span class=\"nf\">can_read_messages?</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>The method may return <code class=\"language-plaintext highlighter-rouge\">false</code> or raise a <code class=\"language-plaintext highlighter-rouge\">GraphQL::ExecutionError</code> to halt execution.</p>\n\n<p>This method is called <em>before</em> <code class=\"language-plaintext highlighter-rouge\">#subscribe</code> and <code class=\"language-plaintext highlighter-rouge\">#update</code>, described below. This way, if a user’s permissions have changed since they subscribed, they won’t receive updates unauthorized updates.</p>\n\n<p>Also, if this method fails before calling <code class=\"language-plaintext highlighter-rouge\">#update</code>, then the client will be automatically unsubscribed (with <code class=\"language-plaintext highlighter-rouge\">#unsubscribe</code>).</p>\n\n<h2 id=\"initial-subscription-with-subscribe\">Initial Subscription with #subscribe</h2>\n\n<p><code class=\"language-plaintext highlighter-rouge\">def subscribe(**args)</code> is called when a client <em>first</em> sends a <code class=\"language-plaintext highlighter-rouge\">subscription { ... }</code> request. In this method, you can do a few things:</p>\n\n<ul>\n  <li>Raise <code class=\"language-plaintext highlighter-rouge\">GraphQL::ExecutionError</code> to halt and return an error</li>\n  <li>Return a value to give the client an initial response</li>\n  <li>Return <code class=\"language-plaintext highlighter-rouge\">:no_response</code> to skip the initial response</li>\n  <li>Return <code class=\"language-plaintext highlighter-rouge\">super</code> to fall back to the default behavior (which is <code class=\"language-plaintext highlighter-rouge\">:no_response</code>).</li>\n</ul>\n\n<p>You can define this method to add initial responses or perform other logic before subscribing.</p>\n\n<h3 id=\"adding-an-initial-response\">Adding an Initial Response</h3>\n\n<p>By default, GraphQL-Ruby returns <em>nothing</em> (<code class=\"language-plaintext highlighter-rouge\">:no_response</code>) on an initial subscription. But, you may choose to override this and return a value in <code class=\"language-plaintext highlighter-rouge\">def subscribe</code>. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::MessageWasPosted</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:room</span><span class=\"p\">,</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">RoomType</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">subscribe</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">:)</span>\n    <span class=\"c1\"># authorize, etc ...</span>\n    <span class=\"c1\"># Return the room in the initial response</span>\n    <span class=\"p\">{</span>\n      <span class=\"ss\">room: </span><span class=\"n\">room</span>\n    <span class=\"p\">}</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Now, a client can get some initial data with:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"p\">(</span><span class=\"nv\">$roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">ID</span><span class=\"p\">!)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">messageWasPosted</span><span class=\"p\">(</span><span class=\"n\">roomId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nv\">$roomId</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"n\">room</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">name</span><span class=\"w\">\n      </span><span class=\"n\">messages</span><span class=\"p\">(</span><span class=\"n\">last</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">40</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n        </span><span class=\"c\"># ...</span><span class=\"w\">\n      </span><span class=\"p\">}</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<h2 id=\"subsequent-updates-with-update\">Subsequent Updates with #update</h2>\n\n<p>After a client has registered a subscription, the application may trigger subscription updates with <code class=\"language-plaintext highlighter-rouge\">MySchema.subscriptions.trigger(...)</code> (see the <a href=\"/subscriptions/triggers\">Triggers guide</a> for more). Then, <code class=\"language-plaintext highlighter-rouge\">def update</code> will be called for each client’s subscription. In this method you can:</p>\n\n<ul>\n  <li>Unsubscribe the client with <code class=\"language-plaintext highlighter-rouge\">unsubscribe</code></li>\n  <li>Return a value with <code class=\"language-plaintext highlighter-rouge\">super</code> (which returns <code class=\"language-plaintext highlighter-rouge\">object</code>) or by returning a different value.</li>\n  <li>Return <code class=\"language-plaintext highlighter-rouge\">NO_UPDATE</code> to skip this update</li>\n</ul>\n\n<h3 id=\"skipping-subscription-updates\">Skipping subscription updates</h3>\n\n<p>Perhaps you don’t want to send updates to a certain subscriber. For example, if someone leaves a comment, you might want to push the new comment to <em>other</em> subscribers, but not the commenter, who already has that comment data. You can accomplish this by returning <code class=\"language-plaintext highlighter-rouge\">NO_UPDATE</code>.</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::CommentWasAdded</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">post_id</span><span class=\"p\">:)</span>\n    <span class=\"n\">comment</span> <span class=\"o\">=</span> <span class=\"n\">object</span> <span class=\"c1\"># #&lt;Comment ...&gt;</span>\n    <span class=\"k\">if</span> <span class=\"n\">comment</span><span class=\"p\">.</span><span class=\"nf\">author</span> <span class=\"o\">==</span> <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"ss\">:viewer</span><span class=\"p\">]</span>\n      <span class=\"no\">NO_UPDATE</span>\n    <span class=\"k\">else</span>\n      <span class=\"c1\"># Continue updating this client, since it's not the commenter</span>\n      <span class=\"k\">super</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<h3 id=\"returning-a-different-object-for-subscription-updates\">Returning a different object for subscription updates</h3>\n\n<p>By default, whatever object you pass to <code class=\"language-plaintext highlighter-rouge\">.trigger(event_name, args, object)</code> will be used for responding to subscription fields. But, you can return a different object from <code class=\"language-plaintext highlighter-rouge\">#update</code> to override this:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">field</span> <span class=\"ss\">:queue</span><span class=\"p\">,</span> <span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">QueueType</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span>\n\n<span class=\"c1\"># eg, `MySchema.subscriptions.trigger(\"queueWasUpdated\", {name: \"low-priority\"}, :low_priority)`</span>\n<span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"nb\">name</span><span class=\"p\">:)</span>\n  <span class=\"c1\"># Make a Queue object which _represents_ the queue with this name</span>\n  <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"no\">JobQueue</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"nb\">name</span><span class=\"p\">)</span>\n\n  <span class=\"c1\"># This object was passed to `.trigger`, but we're ignoring it:</span>\n  <span class=\"n\">object</span> <span class=\"c1\"># =&gt; :low_priority</span>\n\n  <span class=\"c1\"># return the queue instead:</span>\n  <span class=\"p\">{</span> <span class=\"ss\">queue: </span><span class=\"n\">queue</span> <span class=\"p\">}</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<h2 id=\"terminating-the-subscription-with-unsubscribe\">Terminating the subscription with #unsubscribe</h2>\n\n<p>Within a subscription method, you may call <code class=\"language-plaintext highlighter-rouge\">unsubscribe</code> to terminate the client’s subscription, for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">room</span><span class=\"p\">:)</span>\n  <span class=\"k\">if</span> <span class=\"n\">room</span><span class=\"p\">.</span><span class=\"nf\">archived?</span>\n    <span class=\"c1\"># Don't let anyone subscribe to messages on an archived room</span>\n    <span class=\"n\">unsubscribe</span>\n  <span class=\"k\">else</span>\n    <span class=\"k\">super</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">#unsubscribe</code> has the following effects:</p>\n\n<ul>\n  <li>The subscription is unregistered from the backend (this is backend-specific)</li>\n  <li>The client is told to unsubscribe (this is transport-specific)</li>\n</ul>\n\n<p><code class=\"language-plaintext highlighter-rouge\">#unsubscribe</code> does <em>not</em> halt the current update.</p>\n\n<p>Arguments with <code class=\"language-plaintext highlighter-rouge\">loads:</code> configurations will call <code class=\"language-plaintext highlighter-rouge\">unsubscribe</code> if they are <code class=\"language-plaintext highlighter-rouge\">required: true</code> (which is the default) and their ID doesn’t return a value. (It’s assumed that the subscribed object was deleted.)</p>\n\n<h2 id=\"extras\">Extras</h2>\n\n<p>Subscription methods can access query-related metadata by configuring <code class=\"language-plaintext highlighter-rouge\">extras [...]</code> in the class definition. For example, to use a <code class=\"language-plaintext highlighter-rouge\">lookahead</code> and the <code class=\"language-plaintext highlighter-rouge\">ast_node</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::JobFinished</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">::</span><span class=\"no\">Subscription</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">extras</span> <span class=\"p\">[</span><span class=\"ss\">:lookahead</span><span class=\"p\">,</span> <span class=\"ss\">:ast_node</span><span class=\"p\">]</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">subscribe</span><span class=\"p\">(</span><span class=\"n\">lookahead</span><span class=\"p\">:,</span> <span class=\"n\">ast_node</span><span class=\"p\">:)</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">lookahead</span><span class=\"p\">:,</span> <span class=\"n\">ast_node</span><span class=\"p\">:)</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>See the <a href=\"/fields/introduction#extra-field-metadata\">Extra Field Metadata</a> for more information about available metadata.</p>\n",
    "<p><code class=\"language-plaintext highlighter-rouge\">Subscription</code> is the entry point for all subscriptions in a GraphQL system. Each field corresponds to an event which may be subscribed to:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"n\">Subscription</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"c\"># Triggered whenever a post is added</span><span class=\"w\">\n  </span><span class=\"n\">postWasPublished</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"n\">Post</span><span class=\"w\">\n  </span><span class=\"c\"># Triggered whenever a comment is added;</span><span class=\"w\">\n  </span><span class=\"c\"># to watch a certain post, provide a `postId`</span><span class=\"w\">\n  </span><span class=\"n\">commentWasPublished</span><span class=\"p\">(</span><span class=\"n\">postId</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">ID</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"n\">Comment</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>This type is the root for <code class=\"language-plaintext highlighter-rouge\">subscription</code> operations, for example:</p>\n\n<div class=\"language-graphql highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">subscription</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"n\">postWasPublished</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n    </span><span class=\"c\"># This data will be delivered whenever `postWasPublished`</span><span class=\"w\">\n    </span><span class=\"c\"># is triggered by the server:</span><span class=\"w\">\n    </span><span class=\"n\">title</span><span class=\"w\">\n    </span><span class=\"n\">author</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n      </span><span class=\"n\">name</span><span class=\"w\">\n    </span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>To add subscriptions to your system, define an <code class=\"language-plaintext highlighter-rouge\">ObjectType</code> named <code class=\"language-plaintext highlighter-rouge\">Subscription</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># app/graphql/types/subscription_type.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Types::SubscriptionType</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">::</span><span class=\"no\">Object</span>\n  <span class=\"n\">field</span> <span class=\"ss\">:post_was_published</span><span class=\"p\">,</span> <span class=\"ss\">subscription: </span><span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">PostWasPublished</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then, add it as the subscription root with <code class=\"language-plaintext highlighter-rouge\">subscription(...)</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># app/graphql/my_schema.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">QueryType</span><span class=\"p\">)</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"c1\"># Add Subscription to</span>\n  <span class=\"n\">subscription</span><span class=\"p\">(</span><span class=\"no\">Types</span><span class=\"o\">::</span><span class=\"no\">SubscriptionType</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>See <a href=\"/subscriptions/implementation\">Implementing Subscriptions</a> for more about actually delivering updates.</p>\n\n<p>See <a href=\"/subscriptions/subscription_classes\">Subscription Classes</a> for more about implementing subscription root fields.</p>\n",
    "<p>From your application, you can push updates to GraphQL clients with <code class=\"language-plaintext highlighter-rouge\">.trigger</code>.</p>\n\n<p>Events are triggered <em>by name</em>, and the name must match fields on your <a href=\"/subscriptions/subscription_type\">Subscription Type</a></p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Update the system with the new blog post:</span>\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">trigger</span><span class=\"p\">(</span><span class=\"ss\">:post_added</span><span class=\"p\">,</span> <span class=\"p\">{},</span> <span class=\"n\">new_post</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>The arguments are:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">name</code>, which corresponds to the field on subscription type</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">arguments</code>, which corresponds to the arguments on subscription type (for example, if you subscribe to comments on a certain post, the arguments would be <code class=\"language-plaintext highlighter-rouge\">{post_id: comment.post_id}</code>.)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">object</code>, which will be the root object of the subscription update</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">scope:</code> (shown below) for implicitly scoping the clients who will receive updates.</li>\n</ul>\n\n<h2 id=\"scope\">Scope</h2>\n\n<p>To send updates to <em>certain clients only</em>, you can use <code class=\"language-plaintext highlighter-rouge\">scope:</code> to narrow the trigger’s reach.</p>\n\n<p>Scopes are based on query context: a value in <code class=\"language-plaintext highlighter-rouge\">context:</code> is used as the scope; an equivalent value must be passed with <code class=\"language-plaintext highlighter-rouge\">.trigger(... scope:)</code> to update that client. (The value is serialized with <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/Serialize\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::Serialize\"><code>GraphQL::Subscriptions::Serialize</code></a>)</p>\n\n<p>To specify that a topic is scoped, add a <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> option to the Subscription class:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Subscriptions::CommentAdded</span> <span class=\"o\">&lt;</span> <span class=\"no\">Subscription</span><span class=\"o\">::</span><span class=\"no\">BaseSubscription</span>\n  <span class=\"n\">description</span> <span class=\"s2\">\"A comment was added to one of the viewer's posts\"</span>\n  <span class=\"c1\"># For a given viewer, this will be triggered</span>\n  <span class=\"c1\"># whenever one of their posts gets a new comment</span>\n  <span class=\"n\">subscription_scope</span> <span class=\"ss\">:current_user_id</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>(Read more in the <a href=\"/subscriptions/subscription_classes#scope\">Subscription Classes guide</a>.)</p>\n\n<p>Then, subscription operations should have a <code class=\"language-plaintext highlighter-rouge\">context: { current_user_id: ... }</code> value, for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># current_user_id will be the scope for some subscriptions:</span>\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span><span class=\"n\">query_string</span><span class=\"p\">,</span> <span class=\"ss\">context: </span><span class=\"p\">{</span> <span class=\"ss\">current_user_id: </span><span class=\"n\">current_user</span><span class=\"p\">.</span><span class=\"nf\">id</span> <span class=\"p\">})</span>\n</code></pre></div></div>\n\n<p>Finally, when events happen in your app, you should provide the scoping value as <code class=\"language-plaintext highlighter-rouge\">scope:</code>, for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># A new comment is added</span>\n<span class=\"n\">comment</span> <span class=\"o\">=</span> <span class=\"n\">post</span><span class=\"p\">.</span><span class=\"nf\">comments</span><span class=\"p\">.</span><span class=\"nf\">create!</span><span class=\"p\">(</span><span class=\"n\">attrs</span><span class=\"p\">)</span>\n<span class=\"c1\"># notify the author</span>\n<span class=\"n\">author_id</span> <span class=\"o\">=</span> <span class=\"n\">post</span><span class=\"p\">.</span><span class=\"nf\">author</span><span class=\"p\">.</span><span class=\"nf\">id</span>\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">trigger</span><span class=\"p\">(</span><span class=\"ss\">:comment_added</span><span class=\"p\">,</span> <span class=\"p\">{},</span> <span class=\"n\">comment</span><span class=\"p\">,</span> <span class=\"ss\">scope: </span><span class=\"n\">author_id</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Since this trigger has a <code class=\"language-plaintext highlighter-rouge\">scope:</code>, only subscribers with a matching scope value will be updated.</p>\n",
    "<p>GraphQL-Ruby 1.11+ introduced a new algorithm for tracking subscriptions and delivering updates, <em>broadcasts</em>.</p>\n\n<p>A broadcast is a subscription update which is executed <em>once</em>, then delivered to <em>any number</em> of subscribers. This reduces the time your server spends running GraphQL queries, since it doesn’t have to re-run the query for every subscriber.</p>\n\n<p>But, <strong>take care</strong>: this approach risks leaking information to subscribers who shouldn’t receive it.</p>\n\n<h2 id=\"setup\">Setup</h2>\n\n<p>To enable broadcasts, add <code class=\"language-plaintext highlighter-rouge\">broadcast: true</code> to your subscription setup:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MyAppSchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">use</span> <span class=\"no\">SomeSubscriptionImplementation</span><span class=\"p\">,</span>\n    <span class=\"ss\">broadcast: </span><span class=\"kp\">true</span> <span class=\"c1\"># &lt;----</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then, any broadcastable field can be configured with <code class=\"language-plaintext highlighter-rouge\">broadcastable: true</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">field</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"no\">String</span><span class=\"p\">,</span> <span class=\"ss\">null: </span><span class=\"kp\">false</span><span class=\"p\">,</span>\n  <span class=\"ss\">broadcastable: </span><span class=\"kp\">true</span>\n</code></pre></div></div>\n\n<p>When a subscription comes in where <em>all</em> of its fields are <code class=\"language-plaintext highlighter-rouge\">broadcastable: true</code>, then it will be handled as a broadcast.</p>\n\n<p>Additionally, you can set <code class=\"language-plaintext highlighter-rouge\">default_broadcastable: true</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MyAppSchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">use</span> <span class=\"no\">SomeSubscriptionImplementation</span><span class=\"p\">,</span>\n    <span class=\"ss\">broadcast: </span><span class=\"kp\">true</span><span class=\"p\">,</span>\n    <span class=\"ss\">default_broadcastable: </span><span class=\"kp\">true</span> <span class=\"c1\"># &lt;----</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>With this setting, fields are broadcastable by default. Only a field with <code class=\"language-plaintext highlighter-rouge\">broadcastable: false</code> in its configuration will cause a subscription to be handled on a subscriber-by-subscriber basis.</p>\n\n<h2 id=\"what-fields-are-broadcastable\">What fields are broadcastable?</h2>\n\n<p>GraphQL-Ruby can’t infer whether a field is broadcastable or not. You must configure it explicitly with <code class=\"language-plaintext highlighter-rouge\">broadcastable: true</code> or <code class=\"language-plaintext highlighter-rouge\">broadcastable: false</code>. (The subscription plugin also accepts <code class=\"language-plaintext highlighter-rouge\">default_broadcastable: true|false</code>.)</p>\n\n<p>A field is broadcastable if <em>all clients who request the field will see the same value</em>. For example:</p>\n\n<ul>\n  <li>General facts: celebrity names, laws of physics, historical dates</li>\n  <li>Public information: object names, document updated-at timestamps, boilerplate info</li>\n</ul>\n\n<p>For fields like this, you can add <code class=\"language-plaintext highlighter-rouge\">broadcastable: true</code>.</p>\n\n<p>A field is <strong>not broadcastable</strong> if its value is different for different clients. For example:</p>\n\n<ul>\n  <li><strong>Viewer-specific information:</strong> if a field is specifically viewer-based, then it can’t be broadcasted to other viewers. For example, <code class=\"language-plaintext highlighter-rouge\">discussion { viewerCanModerate }</code> might be true for a moderator, but it shouldn’t be broadcasted to other viewers.</li>\n  <li><strong>Context-specific information:</strong> if a field’s value takes the request context into consideration, it shouldn’t be broadcasted. For example, IP addresses or HTTP header values probably can’t be broadcasted. If a field reflects the viewer’s timezone, it can’t be broadcasted.</li>\n  <li><strong>Restricted information:</strong> if some viewers see one value, while other viewers see a different value, then it’s not broadcastable. Broadcasting this data might leak private information to unauthorized clients. (This includes filtered lists: if the filtering is viewer-by-viewer, it’s not broadcastable.)</li>\n  <li><strong>Fields with side effects:</strong> if the system requires a side effect (eg, logging a metric, updating a database, incrementing a counter) whenever a resolver is executed, it’s not a good candidate for broadcasting because some executions will be optimized away.</li>\n</ul>\n\n<p>These fields can be tagged with <code class=\"language-plaintext highlighter-rouge\">broadcastable: false</code> so that GraphQL-Ruby will handle them on a subscriber-by-subscriber basis.</p>\n\n<p>If you want to use subscriptions but have a lot of non-broadcastable fields in your schema, consider building a new set of subscription fields with limited access to other schema objects. Instead, optimize those subscriptions for broacastability.</p>\n\n<h2 id=\"under-the-hood\">Under the Hood</h2>\n\n<p>GraphQL-Ruby determines which subscribers can receive a broadcast by inspecting:</p>\n\n<ul>\n  <li><strong>Query string</strong>. Only exactly-matching query strings will receive the same broadcast.</li>\n  <li><strong>Variables</strong>. Only exactly-matching variable values will receive the same broadcast.</li>\n  <li><strong>Field and Arguments</strong> given to <code class=\"language-plaintext highlighter-rouge\">.trigger</code>. They must match the ones initially sent when subscribing. (Subscriptions always worked this way.)</li>\n  <li><strong>Subscription scope</strong>. Only clients with exactly-matching subscription scope can receive the same broadcasts.</li>\n</ul>\n\n<p>So, take care to <a href=\"/subscriptions/subscription_classes#scope\">set subscription_scope</a> whenever a subscription should be implicitly scoped!</p>\n\n<p>(See <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/Event#fingerprint-instance_method\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::Event#fingerprint\"><code>GraphQL::Subscriptions::Event#fingerprint</code></a> for the implementation of broadcast fingerprints.)</p>\n",
    "<p>The <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions\"><code>GraphQL::Subscriptions</code></a> plugin is a base class for implementing subscriptions.</p>\n\n<p>Each method corresponds to a step in the subscription lifecycle. See the API docs for method-by-method documentation: <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions\"><code>GraphQL::Subscriptions</code></a>.</p>\n\n<p>Also, see the <a href=\"/subscriptions/pusher_implementation\">Pusher implementation guide</a>, the <a href=\"/subscriptions/ably_implementation\">Ably implementation guide</a>, the <a href=\"/subscriptions/action_cable_implementation\">ActionCable implementation guide</a> or <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/ActionCableSubscriptions\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::ActionCableSubscriptions\"><code>GraphQL::Subscriptions::ActionCableSubscriptions</code></a> docs for an example implementation.</p>\n\n<h2 id=\"considerations\">Considerations</h2>\n\n<p>Every Ruby application is different, so consider these points when implementing subscriptions:</p>\n\n<ul>\n  <li>Is your application single-process or multiprocess? Single-process applications can store state in memory while multiprocess applications need a message broker to keep all processes up-to-date.</li>\n  <li>What components of your application can be used for persistence and message passing?</li>\n  <li>How will you deliver push updates to subscribed clients? (For example, websockets, ActionCable, Pusher, webhooks, or something else?)</li>\n  <li>How will you handle <a href=\"https://en.wikipedia.org/wiki/Thundering_herd_problem\">thundering herd</a>s? When an event is triggered, how will you manage database access to update clients without swamping your system?</li>\n</ul>\n\n<h2 id=\"broadcasts\">Broadcasts</h2>\n\n<p><em>Broadcasting</em> updates to multiple subscribers is supported by GraphQL-Ruby, but requires implementation-specific work, see more in the <a href=\"/subscriptions/broadcast\">Broadcast guide</a>.</p>\n",
    "<p><a href=\"https://guides.rubyonrails.org/action_cable_overview.html\">ActionCable</a> is a great platform for delivering GraphQL subscriptions on Rails 5+. It handles message passing (via <code class=\"language-plaintext highlighter-rouge\">broadcast</code>) and transport (via <code class=\"language-plaintext highlighter-rouge\">transmit</code> over a websocket).</p>\n\n<p>To get started, see examples in the API docs: <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/ActionCableSubscriptions\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::ActionCableSubscriptions\"><code>GraphQL::Subscriptions::ActionCableSubscriptions</code></a>.</p>\n\n<p>See client usage for <a href=\"/javascript_client/apollo_subscriptions\">Apollo Client</a> or <a href=\"/javascript_client/relay_subscriptions\">Relay Modern</a>.</p>\n",
    "<p><a href=\"https://graphql.pro\">GraphQL Pro</a> includes a subscription system based on <a href=\"https://redis.io\">Redis</a> and <a href=\"https://pusher.com\">Pusher</a> which works with any Ruby web framework.</p>\n\n<p>After creating an app on Pusher and <a href=\"https://github.com/pusher/pusher-http-ruby#global\">configuring the Ruby gem</a>, you can hook it up to your GraphQL schema.</p>\n\n<h2 id=\"how-it-works\">How it Works</h2>\n\n<p>This subscription implementation uses a hybrid approach:</p>\n\n<ul>\n  <li><strong>Your app</strong> takes GraphQL queries an runs them</li>\n  <li><strong>Redis</strong> stores subscription data for later updates</li>\n  <li><strong>Pusher</strong> sends updates to subscribed clients</li>\n</ul>\n\n<p>So, the lifecycle goes like this:</p>\n\n<ul>\n  <li>A <code class=\"language-plaintext highlighter-rouge\">subscription</code> query is sent by HTTP Post to your server (just like a <code class=\"language-plaintext highlighter-rouge\">query</code> or <code class=\"language-plaintext highlighter-rouge\">mutation</code>)</li>\n  <li>The response contains a Pusher channel ID (as an HTTP header) which the client may subscribe to</li>\n  <li>The client opens that Pusher channel</li>\n  <li>When the server triggers updates, they’re delivered over the Pusher channel</li>\n  <li>When the client unsubscribes, the server receives a webhook and responds by removing its subscription data</li>\n</ul>\n\n<p>Here’s another look:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. Subscription is created in your app\n\n          HTTP POST\n        .----------&gt;   write to Redis\n      📱            ⚙️ -----&gt; 💾\n        &lt;---------'\n        X-Subscription-ID: 1234\n\n\n2. Client opens a connection to Pusher\n\n          websocket\n      📱 &lt;---------&gt; ☁️\n\n\n3. The app sends updates via Pusher\n\n      ⚙️ ---------&gt; ☁️ ------&gt; 📱\n        POST           update\n      (via gem)   (via websocket)\n\n\n4. When the client unsubscribes, Pusher notifies the app\n\n          webhook\n      ⚙️ &lt;-------- ☁️  (disconnect) 📱\n</code></pre></div></div>\n\n<p>By using this configuration, you can use GraphQL subscriptions without hosting a push server yourself!</p>\n\n<h2 id=\"database-setup\">Database setup</h2>\n\n<p>Subscriptions require a <em>persistent</em> Redis database, configured with:</p>\n\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>maxmemory-policy noeviction\n<span class=\"c\"># optional, more durable persistence:</span>\nappendonly <span class=\"nb\">yes</span>\n</code></pre></div></div>\n\n<p>Otherwise, Redis will drop data that doesn’t fit in memory (read more in <a href=\"https://redis.io/topics/persistence\">“Redis persistence”</a>).</p>\n\n<p>If you’re already using Redis in your application, see <a href=\"https://www.mikeperham.com/2015/09/24/storing-data-with-redis/\">“Storing Data in Redis”</a> for options to isolate data and tune your configuration.</p>\n\n<h2 id=\"schema-configuration\">Schema configuration</h2>\n\n<p>Add <code class=\"language-plaintext highlighter-rouge\">redis</code> to your <code class=\"language-plaintext highlighter-rouge\">Gemfile</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gem</span> <span class=\"s1\">'redis'</span>\n</code></pre></div></div>\n\n<p>and <code class=\"language-plaintext highlighter-rouge\">bundle install</code>. Then create a Redis instance:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># for example, in an initializer:</span>\n<span class=\"vg\">$graphql_subscriptions_redis</span> <span class=\"o\">=</span> <span class=\"no\">Redis</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"c1\"># default connection</span>\n</code></pre></div></div>\n\n<p>Then, that Redis client is passed to the Subscription configuration:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"n\">use</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">PusherSubscriptions</span><span class=\"p\">,</span> <span class=\"ss\">redis: </span><span class=\"vg\">$graphql_subscriptions_redis</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>That connection will be used for managing subscription state. All writes to Redis are prefixed with <code class=\"language-plaintext highlighter-rouge\">graphql:sub:</code>.</p>\n\n<p>There are also two configurations for managing persistence:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">stale_ttl_s:</code> expires subscription data after the given number of seconds without any update. After <code class=\"language-plaintext highlighter-rouge\">stale_ttl_s</code> has passed, the data will expire from Redis. Each time a subscription receives an update, its TTL is refreshed. (Generally, this isn’t required because the backend is built to clean itself up. But, if you find that Redis is collecting stale queries, you can set them to expire after some very long time as a safeguard.)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">cleanup_delay_s:</code> (default: <code class=\"language-plaintext highlighter-rouge\">5</code>) prevents deleting a subscription during those first seconds after it’s created. Usually, a longer delay isn’t necessary, but if you observe latency between the subscription’s initial response and the client’s subscription to the delivery channel, you can set this configuration to account for it.</li>\n</ul>\n\n<h2 id=\"execution-configuration\">Execution configuration</h2>\n\n<p>During execution, GraphQL will assign a <code class=\"language-plaintext highlighter-rouge\">subscription_id</code> to the <code class=\"language-plaintext highlighter-rouge\">context</code> hash. The client will use that ID to listen for updates, so you must return the <code class=\"language-plaintext highlighter-rouge\">subscription_id</code> in the response headers.</p>\n\n<p>Return <code class=\"language-plaintext highlighter-rouge\">result.context[:subscription_id]</code> as the <code class=\"language-plaintext highlighter-rouge\">X-Subscription-ID</code> header. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"c1\"># For subscriptions, return the subscription_id as a header</span>\n<span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">subscription?</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-ID\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:subscription_id</span><span class=\"p\">]</span>\n<span class=\"k\">end</span>\n<span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">result</span>\n</code></pre></div></div>\n\n<p>This way, the client can use that ID as a Pusher channel.</p>\n\n<p>For <strong>CORS requests</strong>, you need a special header so that clients can read the custom header:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">subscription?</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-ID\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:subscription_id</span><span class=\"p\">]</span>\n  <span class=\"c1\"># Required for CORS requests:</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"Access-Control-Expose-Headers\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"X-Subscription-ID\"</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Read more here: <a href=\"https://www.html5rocks.com/en/tutorials/cors/\">“Using CORS”</a>.</p>\n\n<h4 id=\"payload-compression\">Payload Compression</h4>\n\n<p>To mitigate problems with <a href=\"https://support.pusher.com/hc/en-us/articles/360019115473-What-is-the-message-size-limit-when-publishing-a-message-in-Channels-\">Pusher’s 10kb message limit</a>, you can specify <code class=\"language-plaintext highlighter-rouge\">compress_pusher_payload: true</code> in the <code class=\"language-plaintext highlighter-rouge\">context</code> of your subscription. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># app/controllers/graphql_controller.rb</span>\n<span class=\"k\">def</span> <span class=\"nf\">execute</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"c1\"># Somehow detect whether the client supports compressed payloads,</span>\n  <span class=\"c1\"># for example, User-Agent, query param, or request header:</span>\n  <span class=\"k\">if</span> <span class=\"n\">client_supports_compressed_payloads?</span>\n    <span class=\"n\">context</span><span class=\"p\">[</span><span class=\"ss\">:compress_pusher_payload</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kp\">true</span>\n  <span class=\"k\">end</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This will cause subscription payloads to include <code class=\"language-plaintext highlighter-rouge\">compressed_result: \"...\"</code> instead of <code class=\"language-plaintext highlighter-rouge\">result: \"...\"</code> when they’re sent over Pusher. See docs for <a href=\"/javascript_client/apollo_subscriptions\">Apollo Client</a> or <a href=\"/javascript_client/relay_subscriptions\">Relay Modern</a> to read about preparing clients for compressed payloads.</p>\n\n<p>By configuring <code class=\"language-plaintext highlighter-rouge\">compress_pusher_payload: true</code> on a query-by-query basis, the subscription backend can continue to support clients running <em>old</em> client code (by not compressing) while upgrading new clients to compressed payloads.</p>\n\n<h2 id=\"webhook-configuration\">Webhook configuration</h2>\n\n<p>Your server needs to receive webhooks from Pusher when clients disconnect. This keeps your local subscription database in sync with Pusher.</p>\n\n<p>In the Pusher web UI, Add a webhook for “Channel existence”</p>\n\n<p><a href=\"/subscriptions/pusher_webhook_configuration.png\" target=\"_blank\" class=\"img-link\">\n  <img src=\"/subscriptions/pusher_webhook_configuration.png\" title=\"Pusher Webhook Configuration\" alt=\"Pusher Webhook Configuration\" />\n</a></p>\n\n<p>Then, mount the Rack app for handling webhooks from Pusher. For example, on Rails:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># config/routes.rb</span>\n\n<span class=\"c1\"># Include GraphQL::Pro's routing extensions:</span>\n<span class=\"n\">using</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">Routes</span>\n\n<span class=\"no\">Rails</span><span class=\"p\">.</span><span class=\"nf\">application</span><span class=\"p\">.</span><span class=\"nf\">routes</span><span class=\"p\">.</span><span class=\"nf\">draw</span> <span class=\"k\">do</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"c1\"># Handle Pusher webhooks for subscriptions:</span>\n  <span class=\"n\">mount</span> <span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">pusher_webhooks_client</span><span class=\"p\">,</span> <span class=\"ss\">at: </span><span class=\"s2\">\"/pusher_webhooks\"</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>This way, we’ll be kept up-to-date with Pusher’s unsubscribe events.</p>\n\n<p><strong>Alternatively</strong>, you can configure the routes to load your schema lazily, during the first request:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Provide the fully-qualified class name of your schema:</span>\n<span class=\"n\">lazy_routes</span> <span class=\"o\">=</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">Routes</span><span class=\"o\">::</span><span class=\"no\">Lazy</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"s2\">\"MySchema\"</span><span class=\"p\">)</span>\n<span class=\"n\">mount</span> <span class=\"n\">lazy_routes</span><span class=\"p\">.</span><span class=\"nf\">pusher_webhooks_client</span><span class=\"p\">,</span> <span class=\"ss\">at: </span><span class=\"s2\">\"/pusher_webhooks\"</span>\n</code></pre></div></div>\n\n<h2 id=\"authorization\">Authorization</h2>\n\n<p>To ensure the privacy of subscription updates, you should use a <a href=\"https://pusher.com/docs/client_api_guide/client_private_channels\">private channel</a> for transport.</p>\n\n<p>To use a private channel, add a <code class=\"language-plaintext highlighter-rouge\">channel_prefix:</code> key to your query context:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span>\n  <span class=\"n\">query_string</span><span class=\"p\">,</span>\n  <span class=\"ss\">context: </span><span class=\"p\">{</span>\n    <span class=\"c1\"># If this query is a subscription, use this prefix for the Pusher channel:</span>\n    <span class=\"ss\">channel_prefix: </span><span class=\"s2\">\"private-user-</span><span class=\"si\">#{</span><span class=\"n\">current_user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"si\">}</span><span class=\"s2\">-\"</span><span class=\"p\">,</span>\n    <span class=\"c1\"># ...</span>\n  <span class=\"p\">},</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>That prefix will be applied to GraphQL-related Pusher channel names. (The prefix should begin with <code class=\"language-plaintext highlighter-rouge\">private-</code>, as required by Pusher.)</p>\n\n<p>Then, in your <a href=\"https://pusher.com/docs/authenticating_users#implementing_private_endpoints\">auth endpoint</a>, you can assert that the logged-in user matches the channel name:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"n\">params</span><span class=\"p\">[</span><span class=\"ss\">:channel_name</span><span class=\"p\">].</span><span class=\"nf\">start_with?</span><span class=\"p\">(</span><span class=\"s2\">\"private-user-</span><span class=\"si\">#{</span><span class=\"n\">current_user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"si\">}</span><span class=\"s2\">-\"</span><span class=\"p\">)</span>\n  <span class=\"c1\"># success, render the auth token</span>\n<span class=\"k\">else</span>\n  <span class=\"c1\"># failure, render unauthorized</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<h2 id=\"serializing-context\">Serializing Context</h2>\n\n<p>Since subscription state is stored in the database, then reloaded for pushing updates, you have to serialize and reload your query <code class=\"language-plaintext highlighter-rouge\">context</code>.</p>\n\n<p>By default, this is done with <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/Serialize\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::Serialize\"><code>GraphQL::Subscriptions::Serialize</code></a>’s <code class=\"language-plaintext highlighter-rouge\">dump</code> and <code class=\"language-plaintext highlighter-rouge\">load</code> methods, but you can provide custom implementations as well. To customize the serialization logic, create a subclass of <code class=\"language-plaintext highlighter-rouge\">GraphQL::Pro::PusherSubscriptions</code> and override <code class=\"language-plaintext highlighter-rouge\">#dump_context(ctx)</code> and <code class=\"language-plaintext highlighter-rouge\">#load_context(ctx_string)</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">CustomSubscriptions</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">PusherSubscriptions</span>\n  <span class=\"k\">def</span> <span class=\"nf\">dump_context</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n    <span class=\"n\">context_hash</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"nf\">to_h</span>\n    <span class=\"c1\"># somehow convert this hash to a string, return the string</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">load_context</span><span class=\"p\">(</span><span class=\"n\">ctx_string</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Given the string from the DB, create a new hash</span>\n    <span class=\"c1\"># to use as `context:`</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then, use your <em>custom</em> subscriptions class instead of the built-in one for your schema:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"c1\"># Use custom subscriptions instead of GraphQL::Pro::PusherSubscriptions</span>\n  <span class=\"c1\"># to get custom serialization logic</span>\n  <span class=\"n\">use</span> <span class=\"no\">CustomSubscriptions</span><span class=\"p\">,</span> <span class=\"ss\">redis: </span><span class=\"vg\">$redis</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>That gives you fine-grained control of context reloading.</p>\n\n<h2 id=\"dashboard\">Dashboard</h2>\n\n<p>You can monitor subscription state in the <a href=\"/pro/dashboard\">GraphQL-Pro Dashboard</a>:</p>\n\n<p><a href=\"/subscriptions/redis_dashboard_1.png\" target=\"_blank\" class=\"img-link\">\n  <img src=\"/subscriptions/redis_dashboard_1.png\" title=\"Redis Subscription Dashboard\" alt=\"Redis Subscription Dashboard\" />\n</a></p>\n\n<p><a href=\"/subscriptions/redis_dashboard_2.png\" target=\"_blank\" class=\"img-link\">\n  <img src=\"/subscriptions/redis_dashboard_2.png\" title=\"Redis Subscription Detail\" alt=\"Redis Subscription Detail\" />\n</a></p>\n\n<h2 id=\"development-tips\">Development Tips</h2>\n\n<h4 id=\"clear-subscription-data\">Clear subscription data</h4>\n\n<p>At any time, you can reset your subscription database with the <strong>“Reset”</strong> button in the <a href=\"/pro/dashboard\">GraphQL-Pro Dashboard</a>, or in Ruby:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Wipe all subscription data from the DB:</span>\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">clear</span>\n</code></pre></div></div>\n\n<h4 id=\"developing-with-pusher-webhooks\">Developing with Pusher webhooks</h4>\n\n<p>To receive Pusher’s webhooks in development, Pusher <a href=\"https://support.pusher.com/hc/en-us/articles/203112227-Developing-against-and-testing-WebHooks\">suggests using ngrok</a>. It gives you a public URL which you can setup with Pusher, then any hooks delivered to that URL will be forwarded to your development environment.</p>\n\n<h2 id=\"client-configuration\">Client configuration</h2>\n\n<p>Install the <a href=\"https://github.com/pusher/pusher-js\">Pusher JS client</a> then see docs for <a href=\"/javascript_client/apollo_subscriptions\">Apollo Client</a> or <a href=\"/javascript_client/relay_subscriptions\">Relay Modern</a>.</p>\n",
    "<p><a href=\"https://graphql.pro\">GraphQL Pro</a> includes a subscription system based on <a href=\"https://redis.io\">Redis</a> and <a href=\"https://ably.io\">Ably</a> which works with any Ruby web framework.</p>\n\n<p>After creating an app on Ably, you can hook it up to your GraphQL schema.</p>\n\n<h2 id=\"how-it-works\">How it Works</h2>\n\n<p>This subscription implementation uses a hybrid approach:</p>\n\n<ul>\n  <li><strong>Your app</strong> takes GraphQL queries an runs them</li>\n  <li><strong>Redis</strong> stores subscription data for later updates</li>\n  <li><strong>Ably</strong> sends updates to subscribed clients</li>\n</ul>\n\n<p>So, the lifecycle goes like this:</p>\n\n<ul>\n  <li>A <code class=\"language-plaintext highlighter-rouge\">subscription</code> query is sent by HTTP Post to your server (just like a <code class=\"language-plaintext highlighter-rouge\">query</code> or <code class=\"language-plaintext highlighter-rouge\">mutation</code>)</li>\n  <li>The response contains a Ably channel ID (as an HTTP header) which the client may subscribe to</li>\n  <li>The client opens that Ably channel</li>\n  <li>When the server triggers updates, they’re delivered over the Ably channel</li>\n  <li>When the client unsubscribes, the server receives a webhook and responds by removing its subscription data</li>\n</ul>\n\n<p>Here’s another look:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. Subscription is created in your app\n\n          HTTP POST\n        .----------&gt;   write to Redis\n      📱            ⚙️ -----&gt; 💾\n        &lt;---------'\n        X-Subscription-ID: 1234\n\n\n2. Client opens a connection to Ably\n\n          websocket\n      📱 &lt;---------&gt; ☁️\n\n\n3. The app sends updates via Ably\n\n      ⚙️ ---------&gt; ☁️ ------&gt; 📱\n        POST           update\n      (via gem)   (via websocket)\n\n\n4. When the client unsubscribes, Ably notifies the app\n\n          webhook\n      ⚙️ &lt;-------- ☁️  (disconnect) 📱\n</code></pre></div></div>\n\n<p>By using this configuration, you can use GraphQL subscriptions without hosting a push server yourself!</p>\n\n<h2 id=\"ably-setup\">Ably setup</h2>\n<p>Add <code class=\"language-plaintext highlighter-rouge\">ably-rest</code> to your <code class=\"language-plaintext highlighter-rouge\">Gemfile</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gem</span> <span class=\"s1\">'ably-rest'</span>\n</code></pre></div></div>\n\n<p>and <code class=\"language-plaintext highlighter-rouge\">bundle install</code>.</p>\n\n<h2 id=\"database-setup\">Database setup</h2>\n\n<p>Subscriptions require a <em>persistent</em> Redis database, configured with:</p>\n\n<div class=\"language-sh highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>maxmemory-policy noeviction\n<span class=\"c\"># optional, more durable persistence:</span>\nappendonly <span class=\"nb\">yes</span>\n</code></pre></div></div>\n\n<p>Otherwise, Redis will drop data that doesn’t fit in memory (read more in <a href=\"https://redis.io/topics/persistence\">“Redis persistence”</a>).</p>\n\n<p>If you’re already using Redis in your application, see <a href=\"https://www.mikeperham.com/2015/09/24/storing-data-with-redis/\">“Storing Data in Redis”</a> for options to isolate data and tune your configuration.</p>\n\n<h2 id=\"schema-configuration\">Schema configuration</h2>\n\n<p>Add <code class=\"language-plaintext highlighter-rouge\">redis</code> to your <code class=\"language-plaintext highlighter-rouge\">Gemfile</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">gem</span> <span class=\"s1\">'redis'</span>\n</code></pre></div></div>\n\n<p>and <code class=\"language-plaintext highlighter-rouge\">bundle install</code>. Then create a Redis instance:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># for example, in an initializer:</span>\n<span class=\"vg\">$graphql_subscriptions_redis</span> <span class=\"o\">=</span> <span class=\"no\">Redis</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"c1\"># default connection</span>\n</code></pre></div></div>\n\n<p>Then, that Redis client is passed to the Subscription configuration:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"n\">use</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">AblySubscriptions</span><span class=\"p\">,</span>\n    <span class=\"ss\">redis: </span><span class=\"vg\">$graphql_subscriptions_redis</span><span class=\"p\">,</span>\n    <span class=\"ss\">ably: </span><span class=\"no\">Ably</span><span class=\"o\">::</span><span class=\"no\">Rest</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">key: </span><span class=\"no\">ABLY_API_KEY</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>That connection will be used for managing subscription state. All writes to Redis are prefixed with <code class=\"language-plaintext highlighter-rouge\">graphql:sub:</code>.</p>\n\n<p>There are also two configurations for managing persistence:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">stale_ttl_s:</code> expires subscription data after the given number of seconds without any update. After <code class=\"language-plaintext highlighter-rouge\">stale_ttl_s</code> has passed, the data will expire from Redis. Each time a subscription receives an update, its TTL is refreshed. (Generally, this isn’t required because the backend is built to clean itself up. But, if you find that Redis is collecting stale queries, you can set them to expire after some very long time as a safeguard.)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">cleanup_delay_s:</code> (default: <code class=\"language-plaintext highlighter-rouge\">5</code>) prevents deleting a subscription during those first seconds after it’s created. Usually, a longer delay isn’t necessary, but if you observe latency between the subscription’s initial response and the client’s subscription to the delivery channel, you can set this configuration to account for it.</li>\n</ul>\n\n<h2 id=\"execution-configuration\">Execution configuration</h2>\n\n<p>During execution, GraphQL will assign a <code class=\"language-plaintext highlighter-rouge\">subscription_id</code> to the <code class=\"language-plaintext highlighter-rouge\">context</code> hash. The client will use that ID to listen for updates, so you must return the <code class=\"language-plaintext highlighter-rouge\">subscription_id</code> in the response headers.</p>\n\n<p>Return <code class=\"language-plaintext highlighter-rouge\">result.context[:subscription_id]</code> as the <code class=\"language-plaintext highlighter-rouge\">X-Subscription-ID</code> header. For example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"c1\"># For subscriptions, return the subscription_id as a header</span>\n<span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">subscription?</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-ID\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:subscription_id</span><span class=\"p\">]</span>\n<span class=\"k\">end</span>\n<span class=\"n\">render</span> <span class=\"ss\">json: </span><span class=\"n\">result</span>\n</code></pre></div></div>\n\n<p>This way, the client can use that ID as a Ably channel.</p>\n\n<p>For <strong>CORS requests</strong>, you need a special header so that clients can read the custom header:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">subscription?</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-ID\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:subscription_id</span><span class=\"p\">]</span>\n  <span class=\"c1\"># Required for CORS requests:</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"Access-Control-Expose-Headers\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"X-Subscription-ID\"</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Read more here: <a href=\"https://www.html5rocks.com/en/tutorials/cors/\">“Using CORS”</a>.</p>\n\n<h2 id=\"webhook-configuration\">Webhook configuration</h2>\n\n<p>Your server needs to receive webhooks from Ably when clients disconnect. This keeps your local subscription database in sync with Ably.</p>\n\n<h3 id=\"server\">Server</h3>\n\n<p><em>Note: if you’re setting up in a development environment you should follow the <a href=\"#Developing-with-webhooks\">Developing with webhooks</a> section first</em></p>\n\n<p>Mount the Rack app for handling webhooks from Ably. For example, on Rails:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># config/routes.rb</span>\n\n<span class=\"c1\"># Include GraphQL::Pro's routing extensions:</span>\n<span class=\"n\">using</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">Routes</span>\n\n<span class=\"no\">Rails</span><span class=\"p\">.</span><span class=\"nf\">application</span><span class=\"p\">.</span><span class=\"nf\">routes</span><span class=\"p\">.</span><span class=\"nf\">draw</span> <span class=\"k\">do</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"c1\"># Handle webhooks for subscriptions:</span>\n  <span class=\"n\">mount</span> <span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">ably_webhooks_client</span><span class=\"p\">,</span> <span class=\"ss\">at: </span><span class=\"s2\">\"/ably_webhooks\"</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p><strong>Alternatively</strong>, you can configure the routes to load your schema lazily, during the first request:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Provide the fully-qualified class name of your schema:</span>\n<span class=\"n\">lazy_routes</span> <span class=\"o\">=</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">Routes</span><span class=\"o\">::</span><span class=\"no\">Lazy</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"s2\">\"MySchema\"</span><span class=\"p\">)</span>\n<span class=\"n\">mount</span> <span class=\"n\">lazy_routes</span><span class=\"p\">.</span><span class=\"nf\">ably_webhooks_client</span><span class=\"p\">,</span> <span class=\"ss\">at: </span><span class=\"s2\">\"/ably_webhooks\"</span>\n</code></pre></div></div>\n\n<h3 id=\"ably\">Ably</h3>\n\n<ol>\n  <li>Go to the Ably dashboard</li>\n  <li>Click on your application.</li>\n  <li>Select the “Reactor” tab</li>\n  <li>Click on the “+ New Reactor Rule” button</li>\n  <li>Click on the “Choose” button for “Reactor Event”</li>\n  <li>Click on the “Choose” button for “WebHooks”</li>\n  <li>Enter your url (including the webhooks path from above) in the URL field.</li>\n  <li>Select “Batch request” for “Request Mode”</li>\n  <li>Under “Source” select “Channel Lifecycle”</li>\n  <li>Under “Sign with key” select the API Key prefix that matches the prefix of the ABLY_API_KEY you provided.</li>\n  <li>Click “Create”</li>\n</ol>\n\n<h2 id=\"authorization\">Authorization</h2>\n\n<p>You can use Ably’s <a href=\"https://www.ably.io/documentation/realtime/authentication#token-authentication\">token authentication</a> by implementing an endpoint in your app, for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">AblyController</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActionController</span><span class=\"o\">::</span><span class=\"no\">Base</span>\n  <span class=\"k\">def</span> <span class=\"nf\">auth</span>\n    <span class=\"n\">render</span> <span class=\"ss\">status: </span><span class=\"mi\">201</span><span class=\"p\">,</span> <span class=\"ss\">json: </span><span class=\"n\">ably_rest_client</span><span class=\"p\">.</span><span class=\"nf\">auth</span><span class=\"p\">.</span><span class=\"nf\">create_token_request</span><span class=\"p\">(</span>\n      <span class=\"ss\">capability: </span><span class=\"p\">{</span> <span class=\"s1\">'*'</span> <span class=\"o\">=&gt;</span> <span class=\"p\">[</span><span class=\"s1\">'presence'</span><span class=\"p\">,</span> <span class=\"s1\">'subscribe'</span><span class=\"p\">]</span> <span class=\"p\">},</span>\n      <span class=\"ss\">client_id: </span><span class=\"s1\">'graphql-subscriber'</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p><a href=\"https://www.ably.io/tutorials/webhook-chuck-norris#tutorial-step-4\">Ably’s tutorial</a> also demonstrates some of the setup for this.</p>\n\n<h2 id=\"encryption\">Encryption</h2>\n\n<p>You can use Ably’s <a href=\"https://www.ably.io/documentation/realtime/encryption\">end-to-end encryption</a> with GraphQL subscriptions. To enable it, add <code class=\"language-plaintext highlighter-rouge\">cipher_base:</code> to your setup:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>  <span class=\"n\">use</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">AblySubscriptions</span><span class=\"p\">,</span>\n    <span class=\"ss\">redis: </span><span class=\"vg\">$graphql_subscriptions_redis</span><span class=\"p\">,</span>\n    <span class=\"ss\">ably: </span><span class=\"no\">Ably</span><span class=\"o\">::</span><span class=\"no\">Rest</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"ss\">key: </span><span class=\"no\">ABLY_API_KEY</span><span class=\"p\">),</span>\n    <span class=\"c1\"># Add `cipher_base:` to enable end-to-end encryption</span>\n    <span class=\"ss\">cipher_base: </span><span class=\"s2\">\"ff16381ae2f2b6c6de6ff696226009f3\"</span>\n</code></pre></div></div>\n\n<p>(Any random string will do, eg <code class=\"language-plaintext highlighter-rouge\">ruby -e \"require 'securerandom'; puts SecureRandom.hex\"</code>.)</p>\n\n<p>Also, return a header to client so that it can decrypt subscription updates. The key is put in <code class=\"language-plaintext highlighter-rouge\">context[:ably_cipher_base64]</code>, and <code class=\"language-plaintext highlighter-rouge\">graphql-ruby-client</code> expects to find it in the <code class=\"language-plaintext highlighter-rouge\">X-Subscription-Key</code> header:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"c1\"># For subscriptions, return the subscription_id as a header</span>\n<span class=\"k\">if</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">subscription?</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-ID\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:subscription_id</span><span class=\"p\">]</span>\n  <span class=\"c1\"># Also return the encryption key so that clients</span>\n  <span class=\"c1\"># can decode subscription updates</span>\n  <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"nf\">headers</span><span class=\"p\">[</span><span class=\"s2\">\"X-Subscription-Key\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">.</span><span class=\"nf\">context</span><span class=\"p\">[</span><span class=\"ss\">:ably_cipher_base64</span><span class=\"p\">]</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>(Also, if you’re using CORS requests, update <code class=\"language-plaintext highlighter-rouge\">Access-Control-Expose-Headers</code> to include <code class=\"language-plaintext highlighter-rouge\">X-Subscription-Key</code>)</p>\n\n<p>With this setup,</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">GraphQL::Pro::AblySubscriptions</code> will generate per-subscription keys (using <code class=\"language-plaintext highlighter-rouge\">cipher_base</code> and the subscription ID) and use them to encrypt Ably payloads</li>\n  <li>Those keys will be returned to clients in <code class=\"language-plaintext highlighter-rouge\">X-Subscription-Key</code></li>\n  <li>Clients will use those keys to decrypt incoming messages</li>\n</ul>\n\n<p><strong>Backwards compatibility:</strong> <code class=\"language-plaintext highlighter-rouge\">GraphQL::Pro::AblySubscriptions</code> will only encrypt payloads whose <code class=\"language-plaintext highlighter-rouge\">query.context[:ably_cipher_base64]</code> is present. Any subscriptions created <em>before</em> <code class=\"language-plaintext highlighter-rouge\">cipher_base:</code> was added to the setup will <em>not</em> be encrypted. (There was no key to encrypt them, and clients don’t have a key to <em>decrypt</em> them!)</p>\n\n<h2 id=\"serializing-context\">Serializing Context</h2>\n\n<p>Since subscription state is stored in the database, then reloaded for pushing updates, you have to serialize and reload your query <code class=\"language-plaintext highlighter-rouge\">context</code>.</p>\n\n<p>By default, this is done with <a href=\"/api-doc/2.0.0/GraphQL/Subscriptions/Serialize\" target=\"_blank\" title=\"API docs for GraphQL::Subscriptions::Serialize\"><code>GraphQL::Subscriptions::Serialize</code></a>’s <code class=\"language-plaintext highlighter-rouge\">dump</code> and <code class=\"language-plaintext highlighter-rouge\">load</code> methods, but you can provide custom implementations as well. To customize the serialization logic, create a subclass of <code class=\"language-plaintext highlighter-rouge\">GraphQL::Pro::AblySubscriptions</code> and override <code class=\"language-plaintext highlighter-rouge\">#dump_context(ctx)</code> and <code class=\"language-plaintext highlighter-rouge\">#load_context(ctx_string)</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">CustomSubscriptions</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">AblySubscriptions</span>\n  <span class=\"k\">def</span> <span class=\"nf\">dump_context</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n    <span class=\"n\">context_hash</span> <span class=\"o\">=</span> <span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"nf\">to_h</span>\n    <span class=\"c1\"># somehow convert this hash to a string, return the string</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">load_context</span><span class=\"p\">(</span><span class=\"n\">ctx_string</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Given the string from the DB, create a new hash</span>\n    <span class=\"c1\"># to use as `context:`</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Then, use your <em>custom</em> subscriptions class instead of the built-in one for your schema:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"c1\"># Use custom subscriptions instead of GraphQL::Pro::AblySubscriptions</span>\n  <span class=\"c1\"># to get custom serialization logic</span>\n  <span class=\"n\">use</span> <span class=\"no\">CustomSubscriptions</span><span class=\"p\">,</span> <span class=\"o\">...</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>That gives you fine-grained control of context reloading.</p>\n\n<h2 id=\"dashboard\">Dashboard</h2>\n\n<p>You can monitor subscription state in the <a href=\"/pro/dashboard\">GraphQL-Pro Dashboard</a>:</p>\n\n<p><a href=\"/subscriptions/redis_dashboard_1.png\" target=\"_blank\" class=\"img-link\">\n  <img src=\"/subscriptions/redis_dashboard_1.png\" title=\"Redis Subscription Dashboard\" alt=\"Redis Subscription Dashboard\" />\n</a></p>\n\n<p><a href=\"/subscriptions/redis_dashboard_2.png\" target=\"_blank\" class=\"img-link\">\n  <img src=\"/subscriptions/redis_dashboard_2.png\" title=\"Redis Subscription Detail\" alt=\"Redis Subscription Detail\" />\n</a></p>\n\n<h2 id=\"development-tips\">Development Tips</h2>\n\n<h4 id=\"clear-subscription-data\">Clear subscription data</h4>\n\n<p>At any time, you can reset your subscription database with the <strong>“Reset”</strong> button in the <a href=\"/pro/dashboard\">GraphQL-Pro Dashboard</a>, or in Ruby:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Wipe all subscription data from the DB:</span>\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">clear</span>\n</code></pre></div></div>\n\n<h4 id=\"developing-with-webhooks\">Developing with webhooks</h4>\n\n<p>To receive webhooks in development, you can <a href=\"https://www.ably.io/tutorials/webhook-chuck-norris\">use ngrok</a>. It gives you a public URL which you can setup with Ably, then any hooks delivered to that URL will be forwarded to your development environment.</p>\n\n<h2 id=\"client-configuration\">Client configuration</h2>\n\n<p>Install the <a href=\"https://github.com/ably/ably-js\">Ably JS client</a> then see docs for <a href=\"/javascript_client/apollo_subscriptions\">Apollo Client</a>.</p>\n",
    "<p>In a multi-tenant system, data from many different accounts is stored on the same server. (An account might be an organization, a customer, a namespace, a domain, etc – these are all <em>tenants</em>.) Gems like <a href=\"https://github.com/influitive/apartment\">Apartment</a> assist with this arrangement, but it can also be implemented in the application. Here are a few considerations for this architecture when using GraphQL subscriptions.</p>\n\n<h2 id=\"add-tenant-to-context\">Add Tenant to <code class=\"language-plaintext highlighter-rouge\">context</code></h2>\n\n<p>All the approaches below will use <code class=\"language-plaintext highlighter-rouge\">context[:tenant]</code> to identify the tenant during GraphQL execution, so make sure to assign it before executing a query:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"ss\">viewer: </span><span class=\"n\">current_user</span><span class=\"p\">,</span>\n  <span class=\"ss\">tenant: </span><span class=\"n\">current_user</span><span class=\"p\">.</span><span class=\"nf\">tenant</span><span class=\"p\">,</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"p\">}</span>\n\n<span class=\"no\">MySchema</span><span class=\"p\">.</span><span class=\"nf\">execute</span><span class=\"p\">(</span><span class=\"n\">query_str</span><span class=\"p\">,</span> <span class=\"ss\">context: </span><span class=\"n\">context</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<h2 id=\"tenant-based-subscription_scope\">Tenant-based <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code></h2>\n\n<p>When subscriptions are delivered, <a href=\"/subscriptions/subscription_classes#scope\"><code class=\"language-plaintext highlighter-rouge\">subscription_scope</code></a> is one element used to route data to the right subscriber. In short, it’s the <em>implicit</em> identifier for the receiver. In a multi-tenant architecture, <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> should reference the context key that names the tenant, for example:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">BudgetWasApproved</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">::</span><span class=\"no\">Subscription</span>\n  <span class=\"n\">subscription_scope</span> <span class=\"ss\">:tenant</span> <span class=\"c1\"># This would work with `context[:tenant] =&gt; \"acme-corp\"`</span>\n  <span class=\"c1\"># ...</span>\n<span class=\"k\">end</span>\n\n<span class=\"c1\"># Include the scope when `.trigger`ing:</span>\n<span class=\"no\">BudgetSchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">trigger</span><span class=\"p\">(</span><span class=\"ss\">:budget_was_approved</span><span class=\"p\">,</span> <span class=\"p\">{},</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">},</span> <span class=\"ss\">scope: </span><span class=\"s2\">\"acme-corp\"</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Alternatively, <code class=\"language-plaintext highlighter-rouge\">subscription_scope</code> might name something that <em>belongs</em> to the tenant:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">BudgetWasApproved</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">::</span><span class=\"no\">Subcription</span>\n  <span class=\"n\">subscription_scope</span> <span class=\"ss\">:project_id</span> <span class=\"c1\"># This would work with `context[:project_id] = 1234`</span>\n<span class=\"k\">end</span>\n\n<span class=\"c1\"># Include the scope when `.trigger`ing:</span>\n<span class=\"no\">BudgetSchema</span><span class=\"p\">.</span><span class=\"nf\">subscriptions</span><span class=\"p\">.</span><span class=\"nf\">trigger</span><span class=\"p\">(</span><span class=\"ss\">:budget_was_approved</span><span class=\"p\">,</span> <span class=\"p\">{},</span> <span class=\"p\">{</span> <span class=\"o\">...</span> <span class=\"p\">},</span> <span class=\"ss\">scope: </span><span class=\"mi\">1234</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>As long as <code class=\"language-plaintext highlighter-rouge\">project_id</code> is unique among <em>all</em> tenants, that would work fine too. But <em>some</em> scope is required so that subscriptions can be disambiguated between tenants.</p>\n\n<h2 id=\"choosing-a-tenant-for-execution\">Choosing a tenant for execution</h2>\n\n<p>There are a few places where subscriptions might need to load data:</p>\n\n<ul>\n  <li>When building the payload for the subscription (fetching data to prepare the result)</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">ActionCableSubscriptions</code>: when deserializing the JSON string broadcasted by <code class=\"language-plaintext highlighter-rouge\">ActionCable</code></li>\n  <li><code class=\"language-plaintext highlighter-rouge\">PusherSubscriptions</code> and <code class=\"language-plaintext highlighter-rouge\">AblySubscriptions</code>: when deserializing query context</li>\n</ul>\n\n<p>Each of these operations will need to select the right tenant in order to load data properly.</p>\n\n<p>For <strong>building the payload</strong>, use a <a href=\"/queries/tracing\">Tracer</a>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">TenantSelectionTracer</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">trace</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n    <span class=\"k\">case</span> <span class=\"n\">event</span>\n    <span class=\"k\">when</span> <span class=\"s2\">\"execute_multiplex\"</span> <span class=\"c1\"># this is the top-level, umbrella event</span>\n      <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">[</span><span class=\"ss\">:multiplex</span><span class=\"p\">].</span><span class=\"nf\">queries</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"p\">.</span><span class=\"nf\">context</span> <span class=\"c1\"># This assumes that all queries in a multiplex have the same tenant</span>\n      <span class=\"no\">MultiTenancy</span><span class=\"p\">.</span><span class=\"nf\">select_tenant</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">[</span><span class=\"ss\">:tenant</span><span class=\"p\">])</span> <span class=\"k\">do</span>\n      <span class=\"c1\"># ^^ your multi-tenancy implementation here</span>\n        <span class=\"k\">yield</span>\n      <span class=\"k\">end</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">yield</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"c1\"># ...</span>\n<span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"n\">tracer</span><span class=\"p\">(</span><span class=\"no\">TenantSelectionTracer</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>The tracer above will use <code class=\"language-plaintext highlighter-rouge\">context[:tenant]</code> to select a tenant for the duration of execution for <em>all</em> queries, mutations, and subscriptions.</p>\n\n<p>For <strong>deserializing ActionCable messages</strong>, provide a <code class=\"language-plaintext highlighter-rouge\">serializer:</code> object that implements <code class=\"language-plaintext highlighter-rouge\">.dump(obj)</code> and <code class=\"language-plaintext highlighter-rouge\">.load(string, context)</code>:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">MultiTenantSerializer</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n    <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">Serialize</span><span class=\"p\">.</span><span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">load</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">)</span>\n    <span class=\"no\">MultiTenancy</span><span class=\"p\">.</span><span class=\"nf\">select_tenant</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">[</span><span class=\"ss\">:tenant</span><span class=\"p\">])</span> <span class=\"k\">do</span>\n      <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">Serialize</span><span class=\"p\">.</span><span class=\"nf\">load</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"c1\"># ...</span>\n<span class=\"k\">class</span> <span class=\"nc\">MySchema</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Schema</span>\n  <span class=\"c1\"># ...</span>\n  <span class=\"n\">use</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Subscriptions</span><span class=\"o\">::</span><span class=\"no\">ActionCableSubscriptions</span><span class=\"p\">,</span> <span class=\"ss\">serializer: </span><span class=\"no\">MultiTenantSerializer</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>The implementation above will use the built-in serialization algorithms, but it will do so <em>in the context of</em> the selected tenant.</p>\n\n<p>For <strong>loading query context in Pusher and Ably</strong>, add tenant selection to your <code class=\"language-plaintext highlighter-rouge\">load_context</code> method, if required:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">CustomSubscriptions</span> <span class=\"o\">&lt;</span> <span class=\"no\">GraphQL</span><span class=\"o\">::</span><span class=\"no\">Pro</span><span class=\"o\">::</span><span class=\"no\">PusherSubscriptions</span> <span class=\"c1\"># or `GraphQL::Pro::AblySubscriptions`</span>\n  <span class=\"k\">def</span> <span class=\"nf\">dump_context</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n    <span class=\"no\">JSON</span><span class=\"p\">.</span><span class=\"nf\">dump</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"nf\">to_h</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">load_context</span><span class=\"p\">(</span><span class=\"n\">ctx_string</span><span class=\"p\">)</span>\n    <span class=\"n\">ctx_data</span> <span class=\"o\">=</span> <span class=\"no\">JSON</span><span class=\"p\">.</span><span class=\"nf\">parse</span><span class=\"p\">(</span><span class=\"n\">ctx_string</span><span class=\"p\">)</span>\n    <span class=\"no\">MultiTenancy</span><span class=\"p\">.</span><span class=\"nf\">select_tenant</span><span class=\"p\">(</span><span class=\"n\">ctx_data</span><span class=\"p\">[</span><span class=\"s2\">\"tenant\"</span><span class=\"p\">])</span> <span class=\"k\">do</span>\n      <span class=\"c1\"># Build a symbol-keyed hash, loading objects from the database if necessary</span>\n      <span class=\"c1\"># to use a `context: ...`</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>With that approach, the selected tenant will be active when building the context hash, in case any objects need to be loaded from the database.</p>\n"
  ],
  "tags": [

  ],
  "categories": [

  ],
  "slug": "ably_implementation",
  "type": "page",
  "url": "/subscriptions/ably_implementation.html"
}